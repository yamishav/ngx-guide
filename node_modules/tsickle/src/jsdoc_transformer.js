/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/jsdoc_transformer", ["require", "exports", "tsickle/src/decorators", "tsickle/src/externs", "tsickle/src/googmodule", "tsickle/src/jsdoc", "tsickle/src/module_type_translator", "tsickle/src/transformer_util", "tsickle/src/type_translator", "tsickle/src/typescript"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @fileoverview jsdoc_transformer contains the logic to add JSDoc comments to TypeScript code.
     *
     * One of tsickle's features is to add Closure Compiler compatible JSDoc comments containing type
     * annotations, inheritance information, etc., onto TypeScript code. This allows Closure Compiler to
     * make better optimization decisions compared to an untyped code base.
     *
     * The entry point to the annotation operation is jsdocTransformer below. It adds synthetic comments
     * to existing TypeScript constructs, for example:
     *     const x: number = 1;
     * Might get transformed to:
     *     /.. \@type {number} ./
     *     const x: number = 1;
     * Later TypeScript phases then remove the type annotation, and the final emit is JavaScript that
     * only contains the JSDoc comment.
     *
     * To handle certain constructs, this transformer also performs AST transformations, e.g. by adding
     * CommonJS-style exports for type constructs, expanding `export *`, parenthesizing casts, etc.
     */
    var decorators_1 = require("tsickle/src/decorators");
    var externs_1 = require("tsickle/src/externs");
    var googmodule = require("tsickle/src/googmodule");
    var jsdoc = require("tsickle/src/jsdoc");
    var module_type_translator_1 = require("tsickle/src/module_type_translator");
    var transformerUtil = require("tsickle/src/transformer_util");
    var type_translator_1 = require("tsickle/src/type_translator");
    var ts = require("tsickle/src/typescript");
    function addCommentOn(node, tags, escapeExtraTags) {
        var comment = jsdoc.toSynthesizedComment(tags, escapeExtraTags);
        var comments = ts.getSyntheticLeadingComments(node) || [];
        comments.push(comment);
        ts.setSyntheticLeadingComments(node, comments);
        return comment;
    }
    /** @return true if node has the specified modifier flag set. */
    function isAmbient(node) {
        var current = node;
        while (current) {
            if (transformerUtil.hasModifierFlag(current, ts.ModifierFlags.Ambient)) {
                return true;
            }
            current = current.parent;
        }
        return false;
    }
    exports.isAmbient = isAmbient;
    /** Adds an \@template clause to docTags if decl has type parameters. */
    function maybeAddTemplateClause(docTags, decl) {
        if (!decl.typeParameters)
            return;
        // Closure does not support template constraints (T extends X), these are ignored below.
        docTags.push({
            tagName: 'template',
            text: decl.typeParameters.map(function (tp) { return transformerUtil.getIdentifierText(tp.name); }).join(', ')
        });
    }
    exports.maybeAddTemplateClause = maybeAddTemplateClause;
    /**
     * Adds heritage clauses (\@extends, \@implements) to the given docTags for decl. Used by
     * jsdoc_transformer and externs generation.
     */
    function maybeAddHeritageClauses(docTags, mtt, decl) {
        var e_1, _a, e_2, _b;
        if (!decl.heritageClauses)
            return;
        var isClass = decl.kind === ts.SyntaxKind.ClassDeclaration;
        var hasExtends = decl.heritageClauses.some(function (c) { return c.token === ts.SyntaxKind.ExtendsKeyword; });
        try {
            for (var _c = __values(decl.heritageClauses), _d = _c.next(); !_d.done; _d = _c.next()) {
                var heritage = _d.value;
                var isExtends = heritage.token === ts.SyntaxKind.ExtendsKeyword;
                if (isClass && isExtends) {
                    // If a class has an "extends", that is preserved in the ES6 output
                    // and we don't need to emit any additional jsdoc.
                    //
                    // However for ambient declarations, we only emit externs, and in those we do need to
                    // add "@extends {Foo}" as they use ES5 syntax.
                    if (!isAmbient(decl))
                        continue;
                }
                try {
                    // Otherwise, if we get here, we need to emit some jsdoc.
                    for (var _e = __values(heritage.types), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var expr = _f.value;
                        var heritage_1 = heritageName(isExtends, hasExtends, expr);
                        // heritageName may return null, indicating that the clause is something inexpressible
                        // in Closure, e.g. "class Foo implements Partial<Bar>".
                        if (!heritage_1) {
                            // For 'extends' clauses that means we cannot emit anything at all.
                            if (!isExtends) {
                                docTags.push({
                                    tagName: isExtends ? 'extends' : 'implements',
                                    type: 'InexpressibleType',
                                });
                            }
                        }
                        else {
                            docTags.push({
                                tagName: heritage_1.tagName,
                                type: heritage_1.parentName,
                            });
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        /**
         * Computes the Closure name of an expression occurring in a heritage clause,
         * e.g. "implements FooBar".  Will return null if the expression is inexpressible
         * in Closure semantics.  Note that we don't need to consider all possible
         * combinations of types/values and extends/implements because our input is
         * already verified to be valid TypeScript.  See test_files/class/ for the full
         * cartesian product of test cases.
         * @param isExtends True if we're in an 'extends', false in an 'implements'.
         * @param hasExtends True if there are any 'extends' clauses present at all.
         */
        function heritageName(isExtends, hasExtends, expr) {
            var tagName = isExtends ? 'extends' : 'implements';
            var sym = mtt.typeChecker.getSymbolAtLocation(expr.expression);
            if (!sym) {
                // It's possible for a class declaration to extend an expression that
                // does not have have a symbol, for example when a mixin function is
                // used to build a base class, as in `declare MyClass extends
                // MyMixin(MyBaseClass)`.
                //
                // Handling this correctly is tricky. Closure throws on this
                // `extends <expression>` syntax (see
                // https://github.com/google/closure-compiler/issues/2182). We would
                // probably need to generate an intermediate class declaration and
                // extend that.
                mtt.debugWarn(decl, "could not resolve supertype: " + expr.getText());
                return null;
            }
            // Resolve any aliases to the underlying type.
            if (sym.flags & ts.SymbolFlags.TypeAlias) {
                // It's implementing a type alias.  Follow the type alias back
                // to the original symbol to check whether it's a type or a value.
                var type = mtt.typeChecker.getDeclaredTypeOfSymbol(sym);
                if (!type.symbol) {
                    // It's not clear when this can happen.
                    mtt.debugWarn(decl, "could not get type of symbol: " + expr.getText());
                    return null;
                }
                sym = type.symbol;
            }
            if (sym.flags & ts.SymbolFlags.Alias) {
                sym = mtt.typeChecker.getAliasedSymbol(sym);
            }
            var typeTranslator = mtt.newTypeTranslator(expr.expression);
            if (typeTranslator.isBlackListed(sym)) {
                // Don't emit references to blacklisted types.
                return null;
            }
            if (sym.flags & ts.SymbolFlags.Class) {
                if (!isClass) {
                    // Closure interfaces cannot extend or implements classes.
                    mtt.debugWarn(decl, "omitting interface deriving from class: " + expr.getText());
                    return null;
                }
                if (!isExtends) {
                    if (!hasExtends) {
                        // A special case: for a class that has no existing 'extends' clause but does
                        // have an 'implements' clause that refers to another class, we change it to
                        // instead be an 'extends'.  This was a poorly-thought-out hack that may
                        // actually cause compiler bugs:
                        //   https://github.com/google/closure-compiler/issues/3126
                        // but we have code that now relies on it, ugh.
                        tagName = 'extends';
                    }
                    else {
                        // Closure can only @implements an interface, not a class.
                        mtt.debugWarn(decl, "omitting @implements of a class: " + expr.getText());
                        return null;
                    }
                }
            }
            else if (sym.flags & ts.SymbolFlags.Value) {
                // If it's something other than a class in the value namespace, then it will
                // not be a type in the Closure output (because Closure collapses
                // the type and value namespaces).
                mtt.debugWarn(decl, "omitting heritage reference to a type/value conflict: " + expr.getText());
                return null;
            }
            else if (sym.flags & ts.SymbolFlags.TypeLiteral) {
                // A type literal is a type like `{foo: string}`.
                // These can come up as the output of a mapped type.
                mtt.debugWarn(decl, "omitting heritage reference to a type literal: " + expr.getText());
                return null;
            }
            // typeToClosure includes nullability modifiers, so call symbolToString directly here.
            var parentName = typeTranslator.symbolToString(sym);
            if (!parentName)
                return null;
            return { tagName: tagName, parentName: parentName };
        }
    }
    exports.maybeAddHeritageClauses = maybeAddHeritageClauses;
    /**
     * createMemberTypeDeclaration emits the type annotations for members of a class. It's necessary in
     * the case where TypeScript syntax specifies there are additional properties on the class, because
     * to declare these in Closure you must declare these separately from the class.
     *
     * createMemberTypeDeclaration produces an if (false) statement containing property declarations, or
     * null if no declarations could or needed to be generated (e.g. no members, or an unnamed type).
     * The if statement is used to make sure the code is not executed, otherwise property accesses could
     * trigger getters on a superclass. See test_files/fields/fields.ts:BaseThatThrows.
     */
    function createMemberTypeDeclaration(mtt, typeDecl) {
        var e_3, _a, e_4, _b;
        // Gather parameter properties from the constructor, if it exists.
        var ctors = [];
        var paramProps = [];
        var nonStaticProps = [];
        var staticProps = [];
        var unhandled = [];
        var abstractMethods = [];
        try {
            for (var _c = __values(typeDecl.members), _d = _c.next(); !_d.done; _d = _c.next()) {
                var member = _d.value;
                if (member.kind === ts.SyntaxKind.Constructor) {
                    ctors.push(member);
                }
                else if (ts.isPropertyDeclaration(member) || ts.isPropertySignature(member)) {
                    var isStatic = transformerUtil.hasModifierFlag(member, ts.ModifierFlags.Static);
                    if (isStatic) {
                        staticProps.push(member);
                    }
                    else {
                        nonStaticProps.push(member);
                    }
                }
                else if (member.kind === ts.SyntaxKind.MethodDeclaration ||
                    member.kind === ts.SyntaxKind.MethodSignature ||
                    member.kind === ts.SyntaxKind.GetAccessor || member.kind === ts.SyntaxKind.SetAccessor) {
                    if (transformerUtil.hasModifierFlag(member, ts.ModifierFlags.Abstract) ||
                        ts.isInterfaceDeclaration(typeDecl)) {
                        abstractMethods.push(member);
                    }
                    // Non-abstract methods only exist on classes, and are handled in regular emit.
                }
                else {
                    unhandled.push(member);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (ctors.length > 0) {
            // Only the actual constructor implementation, which must be last in a potential sequence of
            // overloaded constructors, may contain parameter properties.
            var ctor = ctors[ctors.length - 1];
            paramProps = ctor.parameters.filter(function (p) { return transformerUtil.hasModifierFlag(p, ts.ModifierFlags.ParameterPropertyModifier); });
        }
        if (nonStaticProps.length === 0 && paramProps.length === 0 && staticProps.length === 0 &&
            abstractMethods.length === 0) {
            // There are no members so we don't need to emit any type
            // annotations helper.
            return null;
        }
        if (!typeDecl.name) {
            mtt.debugWarn(typeDecl, 'cannot add types on unnamed declarations');
            return null;
        }
        var className = transformerUtil.getIdentifierText(typeDecl.name);
        var staticPropAccess = ts.createIdentifier(className);
        var instancePropAccess = ts.createPropertyAccess(staticPropAccess, 'prototype');
        // Closure Compiler will report conformance errors about this being unknown type when emitting
        // class properties as {?|undefined}, instead of just {?}. So make sure to only emit {?|undefined}
        // on interfaces.
        var isInterface = ts.isInterfaceDeclaration(typeDecl);
        var propertyDecls = staticProps.map(function (p) { return createClosurePropertyDeclaration(mtt, staticPropAccess, p, isInterface && !!p.questionToken); });
        propertyDecls.push.apply(propertyDecls, __spread(__spread(nonStaticProps, paramProps).map(function (p) { return createClosurePropertyDeclaration(mtt, instancePropAccess, p, isInterface && !!p.questionToken); })));
        propertyDecls.push.apply(propertyDecls, __spread(unhandled.map(function (p) { return transformerUtil.createMultiLineComment(p, "Skipping unhandled member: " + escapeForComment(p.getText())); })));
        try {
            for (var abstractMethods_1 = __values(abstractMethods), abstractMethods_1_1 = abstractMethods_1.next(); !abstractMethods_1_1.done; abstractMethods_1_1 = abstractMethods_1.next()) {
                var fnDecl = abstractMethods_1_1.value;
                var name_1 = propertyName(fnDecl);
                if (!name_1) {
                    mtt.error(fnDecl, 'anonymous abstract function');
                    continue;
                }
                var _e = mtt.getFunctionTypeJSDoc([fnDecl], []), tags = _e.tags, parameterNames = _e.parameterNames;
                if (decorators_1.hasExportingDecorator(fnDecl, mtt.typeChecker))
                    tags.push({ tagName: 'export' });
                // memberNamespace because abstract methods cannot be static in TypeScript.
                var abstractFnDecl = ts.createStatement(ts.createAssignment(ts.createPropertyAccess(instancePropAccess, name_1), ts.createFunctionExpression(
                /* modifiers */ undefined, 
                /* asterisk */ undefined, 
                /* name */ undefined, 
                /* typeParameters */ undefined, parameterNames.map(function (n) { return ts.createParameter(
                /* decorators */ undefined, /* modifiers */ undefined, 
                /* dotDotDot */ undefined, n); }), undefined, ts.createBlock([]))));
                ts.setSyntheticLeadingComments(abstractFnDecl, [jsdoc.toSynthesizedComment(tags)]);
                propertyDecls.push(ts.setSourceMapRange(abstractFnDecl, fnDecl));
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (abstractMethods_1_1 && !abstractMethods_1_1.done && (_b = abstractMethods_1.return)) _b.call(abstractMethods_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        // See test_files/fields/fields.ts:BaseThatThrows for a note on this wrapper.
        return ts.createIf(ts.createLiteral(false), ts.createBlock(propertyDecls, true));
    }
    function propertyName(prop) {
        if (!prop.name)
            return null;
        switch (prop.name.kind) {
            case ts.SyntaxKind.Identifier:
                return transformerUtil.getIdentifierText(prop.name);
            case ts.SyntaxKind.StringLiteral:
                // E.g. interface Foo { 'bar': number; }
                // If 'bar' is a name that is not valid in Closure then there's nothing we can do.
                var text = prop.name.text;
                if (!type_translator_1.isValidClosurePropertyName(text))
                    return null;
                return text;
            default:
                return null;
        }
    }
    /** Removes comment metacharacters from a string, to make it safe to embed in a comment. */
    function escapeForComment(str) {
        return str.replace(/\/\*/g, '__').replace(/\*\//g, '__');
    }
    exports.escapeForComment = escapeForComment;
    function createClosurePropertyDeclaration(mtt, expr, prop, optional) {
        var name = propertyName(prop);
        if (!name) {
            mtt.debugWarn(prop, "handle unnamed member:\n" + escapeForComment(prop.getText()));
            return transformerUtil.createMultiLineComment(prop, "Skipping unnamed member:\n" + escapeForComment(prop.getText()));
        }
        var type = mtt.typeToClosure(prop);
        // When a property is optional, e.g.
        //   foo?: string;
        // Then the TypeScript type of the property is string|undefined, the
        // typeToClosure translation handles it correctly, and string|undefined is
        // how you write an optional property in Closure.
        //
        // But in the special case of an optional property with type any:
        //   foo?: any;
        // The TypeScript type of the property is just "any" (because any includes
        // undefined as well) so our default translation of the type is just "?".
        // To mark the property as optional in Closure it must have "|undefined",
        // so the Closure type must be ?|undefined.
        if (optional && type === '?')
            type += '|undefined';
        var tags = mtt.getJSDoc(prop, /* reportWarnings */ true);
        tags.push({ tagName: 'type', type: type });
        if (decorators_1.hasExportingDecorator(prop, mtt.typeChecker)) {
            tags.push({ tagName: 'export' });
        }
        var declStmt = ts.setSourceMapRange(ts.createStatement(ts.createPropertyAccess(expr, name)), prop);
        // Avoid printing annotations that can conflict with @type
        // This avoids Closure's error "type annotation incompatible with other annotations"
        addCommentOn(declStmt, tags, jsdoc.TAGS_CONFLICTING_WITH_TYPE);
        return declStmt;
    }
    /**
     * Removes any type assertions and non-null expressions from the AST before TypeScript processing.
     *
     * Ideally, the code in jsdoc_transformer below should just remove the cast expression and
     * replace it with the Closure equivalent. However Angular's compiler is fragile to AST
     * nodes being removed or changing type, so the code must retain the type assertion
     * expression, see: https://github.com/angular/angular/issues/24895.
     *
     * tsickle also cannot just generate and keep a `(/.. @type {SomeType} ./ (expr as SomeType))`
     * because TypeScript removes the parenthesized expressions in that syntax, (reasonably) believing
     * they were only added for the TS cast.
     *
     * The final workaround is then to keep the TypeScript type assertions, and have a post-Angular
     * processing step that removes the assertions before TypeScript sees them.
     *
     * TODO(martinprobst): remove once the Angular issue is fixed.
     */
    function removeTypeAssertions() {
        return function (context) {
            return function (sourceFile) {
                function visitor(node) {
                    switch (node.kind) {
                        case ts.SyntaxKind.TypeAssertionExpression:
                        case ts.SyntaxKind.AsExpression:
                            return ts.visitNode(node.expression, visitor);
                        case ts.SyntaxKind.NonNullExpression:
                            return ts.visitNode(node.expression, visitor);
                        default:
                            break;
                    }
                    return ts.visitEachChild(node, visitor, context);
                }
                return visitor(sourceFile);
            };
        };
    }
    exports.removeTypeAssertions = removeTypeAssertions;
    /**
     * jsdocTransformer returns a transformer factory that converts TypeScript types into the equivalent
     * JSDoc annotations.
     */
    function jsdocTransformer(host, tsOptions, tsHost, typeChecker, diagnostics) {
        return function (context) {
            return function (sourceFile) {
                var moduleTypeTranslator = new module_type_translator_1.ModuleTypeTranslator(sourceFile, typeChecker, host, diagnostics, /*isForExterns*/ false);
                /**
                 * The set of all names exported from an export * in the current module. Used to prevent
                 * emitting duplicated exports. The first export * takes precedence in ES6.
                 */
                var expandedStarImports = new Set();
                /**
                 * While Closure compiler supports parameterized types, including parameterized `this` on
                 * methods, it does not support constraints on them. That means that an `\@template`d type is
                 * always considered to be `unknown` within the method, including `THIS`.
                 *
                 * To help Closure Compiler, we keep track of any templated this return type, and substitute
                 * explicit casts to the templated type.
                 *
                 * This is an incomplete solution and works around a specific problem with warnings on unknown
                 * this accesses. More generally, Closure also cannot infer constraints for any other
                 * templated types, but that might require a more general solution in Closure Compiler.
                 */
                var contextThisType = null;
                function visitClassDeclaration(classDecl) {
                    var contextThisTypeBackup = contextThisType;
                    var mjsdoc = moduleTypeTranslator.getMutableJSDoc(classDecl);
                    if (transformerUtil.hasModifierFlag(classDecl, ts.ModifierFlags.Abstract)) {
                        mjsdoc.tags.push({ tagName: 'abstract' });
                    }
                    maybeAddTemplateClause(mjsdoc.tags, classDecl);
                    if (!host.untyped) {
                        maybeAddHeritageClauses(mjsdoc.tags, moduleTypeTranslator, classDecl);
                    }
                    mjsdoc.updateComment();
                    var decls = [];
                    var memberDecl = createMemberTypeDeclaration(moduleTypeTranslator, classDecl);
                    // WARNING: order is significant; we must create the member decl before transforming away
                    // parameter property comments when visiting the constructor.
                    decls.push(ts.visitEachChild(classDecl, visitor, context));
                    if (memberDecl)
                        decls.push(memberDecl);
                    contextThisType = contextThisTypeBackup;
                    return decls;
                }
                /**
                 * visitHeritageClause works around a Closure Compiler issue, where the expression in an
                 * "extends" clause must be a simple identifier, and in particular must not be a parenthesized
                 * expression.
                 *
                 * This is triggered when TS code writes "class X extends (Foo as Bar) { ... }", commonly done
                 * to support mixins. For extends clauses in classes, the code below drops the cast and any
                 * parentheticals, leaving just the original expression.
                 *
                 * This is an incomplete workaround, as Closure will still bail on other super expressions,
                 * but retains compatibility with the previous emit that (accidentally) dropped the cast
                 * expression.
                 *
                 * TODO(martinprobst): remove this once the Closure side issue has been resolved.
                 */
                function visitHeritageClause(heritageClause) {
                    if (heritageClause.token !== ts.SyntaxKind.ExtendsKeyword || !heritageClause.parent ||
                        heritageClause.parent.kind === ts.SyntaxKind.InterfaceDeclaration) {
                        return ts.visitEachChild(heritageClause, visitor, context);
                    }
                    if (heritageClause.types.length !== 1) {
                        moduleTypeTranslator.error(heritageClause, "expected exactly one type in class extension clause");
                    }
                    var type = heritageClause.types[0];
                    var expr = type.expression;
                    while (ts.isParenthesizedExpression(expr) || ts.isNonNullExpression(expr) ||
                        ts.isAssertionExpression(expr)) {
                        expr = expr.expression;
                    }
                    return ts.updateHeritageClause(heritageClause, [ts.updateExpressionWithTypeArguments(type, type.typeArguments || [], expr)]);
                }
                function visitInterfaceDeclaration(iface) {
                    var sym = typeChecker.getSymbolAtLocation(iface.name);
                    if (!sym) {
                        moduleTypeTranslator.error(iface, 'interface with no symbol');
                        return [];
                    }
                    // If this symbol is both a type and a value, we cannot emit both into Closure's
                    // single namespace.
                    if (sym.flags & ts.SymbolFlags.Value) {
                        moduleTypeTranslator.debugWarn(iface, "type/symbol conflict for " + sym.name + ", using {?} for now");
                        return [transformerUtil.createSingleLineComment(iface, 'WARNING: interface has both a type and a value, skipping emit')];
                    }
                    var tags = moduleTypeTranslator.getJSDoc(iface, /* reportWarnings */ true) || [];
                    tags.push({ tagName: 'record' });
                    maybeAddTemplateClause(tags, iface);
                    if (!host.untyped) {
                        maybeAddHeritageClauses(tags, moduleTypeTranslator, iface);
                    }
                    var name = transformerUtil.getIdentifierText(iface.name);
                    var modifiers = transformerUtil.hasModifierFlag(iface, ts.ModifierFlags.Export) ?
                        [ts.createToken(ts.SyntaxKind.ExportKeyword)] :
                        undefined;
                    var decl = ts.setSourceMapRange(ts.createFunctionDeclaration(
                    /* decorators */ undefined, modifiers, 
                    /* asterisk */ undefined, name, 
                    /* typeParameters */ undefined, 
                    /* parameters */ [], 
                    /* type */ undefined, 
                    /* body */ ts.createBlock([])), iface);
                    addCommentOn(decl, tags);
                    var memberDecl = createMemberTypeDeclaration(moduleTypeTranslator, iface);
                    return memberDecl ? [decl, memberDecl] : [decl];
                }
                /** Function declarations are emitted as they are, with only JSDoc added. */
                function visitFunctionLikeDeclaration(fnDecl) {
                    if (!fnDecl.body) {
                        // Two cases: abstract methods and overloaded methods/functions.
                        // Abstract methods are handled in emitTypeAnnotationsHandler.
                        // Overloads are union-ized into the shared type in FunctionType.
                        return ts.visitEachChild(fnDecl, visitor, context);
                    }
                    var extraTags = [];
                    if (decorators_1.hasExportingDecorator(fnDecl, typeChecker))
                        extraTags.push({ tagName: 'export' });
                    var _a = moduleTypeTranslator.getFunctionTypeJSDoc([fnDecl], extraTags), tags = _a.tags, thisReturnType = _a.thisReturnType;
                    var mjsdoc = moduleTypeTranslator.getMutableJSDoc(fnDecl);
                    mjsdoc.tags = tags;
                    mjsdoc.updateComment();
                    moduleTypeTranslator.blacklistTypeParameters(fnDecl, fnDecl.typeParameters);
                    var contextThisTypeBackup = contextThisType;
                    contextThisType = thisReturnType;
                    var result = ts.visitEachChild(fnDecl, visitor, context);
                    contextThisType = contextThisTypeBackup;
                    return result;
                }
                /**
                 * In methods with a templated this type, adds explicit casts to accesses on this.
                 *
                 * @see contextThisType
                 */
                function visitThisExpression(node) {
                    if (!contextThisType)
                        return ts.visitEachChild(node, visitor, context);
                    return createClosureCast(node, node, contextThisType);
                }
                /**
                 * visitVariableStatement flattens variable declaration lists (`var a, b;` to `var a; var
                 * b;`), and attaches JSDoc comments to each variable. JSDoc comments preceding the
                 * original variable are attached to the first newly created one.
                 */
                function visitVariableStatement(varStmt) {
                    var e_5, _a;
                    var stmts = [];
                    // "const", "let", etc are stored in node flags on the declarationList.
                    var flags = ts.getCombinedNodeFlags(varStmt.declarationList);
                    var tags = moduleTypeTranslator.getJSDoc(varStmt, /* reportWarnings */ true);
                    var leading = ts.getSyntheticLeadingComments(varStmt);
                    if (leading) {
                        // Attach non-JSDoc comments to a not emitted statement.
                        var commentHolder = ts.createNotEmittedStatement(varStmt);
                        ts.setSyntheticLeadingComments(commentHolder, leading.filter(function (c) { return c.text[0] !== '*'; }));
                        stmts.push(commentHolder);
                    }
                    var declList = ts.visitNode(varStmt.declarationList, visitor);
                    try {
                        for (var _b = __values(declList.declarations), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var decl = _c.value;
                            var localTags = [];
                            if (tags) {
                                // Add any tags and docs preceding the entire statement to the first variable.
                                localTags.push.apply(localTags, __spread(tags));
                                tags = null;
                            }
                            // Add an @type for plain identifiers, but not for bindings patterns (i.e. object or array
                            // destructuring) - those do not have a syntax in Closure.
                            if (ts.isIdentifier(decl.name)) {
                                // For variables that are initialized and use a blacklisted type, do not emit a type at
                                // all. Closure Compiler might be able to infer a better type from the initializer than
                                // the `?` the code below would emit.
                                // TODO(martinprobst): consider doing this for all types that get emitted as ?, not just
                                // for blacklisted ones.
                                var blackListedInitialized = !!decl.initializer && moduleTypeTranslator.isBlackListed(decl);
                                if (!blackListedInitialized) {
                                    // getOriginalNode(decl) is required because the type checker cannot type check
                                    // synthesized nodes.
                                    var typeStr = moduleTypeTranslator.typeToClosure(ts.getOriginalNode(decl));
                                    localTags.push({ tagName: 'type', type: typeStr });
                                }
                            }
                            var newStmt = ts.createVariableStatement(varStmt.modifiers, ts.createVariableDeclarationList([decl], flags));
                            if (localTags.length)
                                addCommentOn(newStmt, localTags, jsdoc.TAGS_CONFLICTING_WITH_TYPE);
                            stmts.push(newStmt);
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                    return stmts;
                }
                /**
                 * shouldEmitExportsAssignments returns true if tsickle should emit `exports.Foo = ...` style
                 * export statements.
                 *
                 * TypeScript modules can export types. Because types are pure design-time constructs in
                 * TypeScript, it does not emit any actual exported symbols for these. But tsickle has to emit
                 * an export, so that downstream Closure code (including tsickle-converted Closure code) can
                 * import upstream types. tsickle has to pick a module format for that, because the pure ES6
                 * export would get stripped by TypeScript.
                 *
                 * tsickle uses CommonJS to emit googmodule, and code not using googmodule doesn't care about
                 * the Closure annotations anyway, so tsickle skips emitting exports if the module target
                 * isn't commonjs.
                 */
                function shouldEmitExportsAssignments() {
                    return tsOptions.module === ts.ModuleKind.CommonJS;
                }
                function visitTypeAliasDeclaration(typeAlias) {
                    // If the type is also defined as a value, skip emitting it. Closure collapses type & value
                    // namespaces, the two emits would conflict if tsickle emitted both.
                    var sym = moduleTypeTranslator.mustGetSymbolAtLocation(typeAlias.name);
                    if (sym.flags & ts.SymbolFlags.Value)
                        return [];
                    // Type aliases are always emitted as the resolved underlying type, so there is no need to
                    // emit anything, except for exported types.
                    if (!transformerUtil.hasModifierFlag(typeAlias, ts.ModifierFlags.Export))
                        return [];
                    if (!shouldEmitExportsAssignments())
                        return [];
                    var typeName = typeAlias.name.getText();
                    // Blacklist any type parameters, Closure does not support type aliases with type
                    // parameters.
                    moduleTypeTranslator.newTypeTranslator(typeAlias).blacklistTypeParameters(moduleTypeTranslator.symbolsToAliasedNames, typeAlias.typeParameters);
                    var typeStr = host.untyped ? '?' : moduleTypeTranslator.typeToClosure(typeAlias, undefined);
                    // In the case of an export, we cannot emit a `export var foo;` because TypeScript drops
                    // exports that are never assigned values, and Closure requires us to not assign values to
                    // typedef exports. Introducing a new local variable and exporting it can cause bugs due to
                    // name shadowing and confusing TypeScript's logic on what symbols and types vs values are
                    // exported. Mangling the name to avoid the conflicts would be reasonably clean, but would
                    // require a two pass emit to first find all type alias names, mangle them, and emit the use
                    // sites only later. With that, the fix here is to never emit type aliases, but always
                    // resolve the alias and emit the underlying type (fixing references in the local module,
                    // and also across modules). For downstream JavaScript code that imports the typedef, we
                    // emit an "export.Foo;" that declares and exports the type, and for TypeScript has no
                    // impact.
                    var tags = moduleTypeTranslator.getJSDoc(typeAlias, /* reportWarnings */ true);
                    tags.push({ tagName: 'typedef', type: typeStr });
                    var decl = ts.setSourceMapRange(ts.createStatement(ts.createPropertyAccess(ts.createIdentifier('exports'), ts.createIdentifier(typeName))), typeAlias);
                    addCommentOn(decl, tags, jsdoc.TAGS_CONFLICTING_WITH_TYPE);
                    return [decl];
                }
                /** Emits a parenthesized Closure cast: `(/** \@type ... * / (expr))`. */
                function createClosureCast(context, expression, type) {
                    var inner = ts.createParen(expression);
                    var comment = addCommentOn(inner, [{ tagName: 'type', type: moduleTypeTranslator.typeToClosure(context, type) }]);
                    comment.hasTrailingNewLine = false;
                    return ts.setSourceMapRange(ts.createParen(inner), context);
                }
                /** Converts a TypeScript type assertion into a Closure Cast. */
                function visitAssertionExpression(assertion) {
                    var type = typeChecker.getTypeAtLocation(assertion.type);
                    return createClosureCast(assertion, ts.visitEachChild(assertion, visitor, context), type);
                }
                /**
                 * Converts a TypeScript non-null assertion into a Closure Cast, by stripping |null and
                 * |undefined from a union type.
                 */
                function visitNonNullExpression(nonNull) {
                    var type = typeChecker.getTypeAtLocation(nonNull.expression);
                    var nonNullType = typeChecker.getNonNullableType(type);
                    return createClosureCast(nonNull, ts.visitEachChild(nonNull, visitor, context), nonNullType);
                }
                function visitImportDeclaration(importDecl) {
                    // No need to forward declare side effect imports.
                    if (!importDecl.importClause)
                        return importDecl;
                    // Introduce a goog.forwardDeclare for the module, so that if TypeScript does not emit the
                    // module because it's only used in type positions, the JSDoc comments still reference a
                    // valid Closure level symbol.
                    var sym = typeChecker.getSymbolAtLocation(importDecl.moduleSpecifier);
                    // Scripts do not have a symbol, and neither do unused modules. Scripts can still be
                    // imported, either as side effect imports or with an empty import set ("{}"). TypeScript
                    // does not emit a runtime load for an import with an empty list of symbols, but the import
                    // forces any global declarations from the library to be visible, which is what users use
                    // this for. No symbols from the script need forward declaration, so just return.
                    if (!sym)
                        return importDecl;
                    // Write the export declaration here so that forward declares come after it, and
                    // fileoverview comments do not get moved behind statements.
                    var importPath = googmodule.resolveModuleName({ options: tsOptions, host: tsHost }, sourceFile.fileName, importDecl.moduleSpecifier.text);
                    moduleTypeTranslator.forwardDeclare(importPath, sym, /* isExplicitlyImported? */ true, 
                    /* default import? */ !!importDecl.importClause.name);
                    return importDecl;
                }
                /**
                 * Closure Compiler will fail when it finds incorrect JSDoc tags on nodes. This function
                 * parses and then re-serializes JSDoc comments, escaping or removing illegal tags.
                 */
                function escapeIllegalJSDoc(node) {
                    var mjsdoc = moduleTypeTranslator.getMutableJSDoc(node);
                    mjsdoc.updateComment();
                }
                /** Returns true if a value export should be emitted for the given symbol in export *. */
                function shouldEmitValueExportForSymbol(sym) {
                    if (sym.flags & ts.SymbolFlags.Alias) {
                        sym = typeChecker.getAliasedSymbol(sym);
                    }
                    if ((sym.flags & ts.SymbolFlags.Value) === 0) {
                        // Note: We create explicit exports of type symbols for closure in visitExportDeclaration.
                        return false;
                    }
                    if (!tsOptions.preserveConstEnums && sym.flags & ts.SymbolFlags.ConstEnum) {
                        return false;
                    }
                    return true;
                }
                /**
                 * visitExportDeclaration forward declares exported modules and emits explicit exports for
                 * types (which normally do not get emitted by TypeScript).
                 */
                function visitExportDeclaration(exportDecl) {
                    var e_6, _a, e_7, _b, e_8, _c;
                    var importedModuleSymbol = exportDecl.moduleSpecifier &&
                        typeChecker.getSymbolAtLocation(exportDecl.moduleSpecifier);
                    if (importedModuleSymbol) {
                        // Forward declare all explicitly imported modules, so that symbols can be referenced and
                        // type only modules get force-loaded.
                        moduleTypeTranslator.forwardDeclare(exportDecl.moduleSpecifier.text, importedModuleSymbol, 
                        /* isExplicitlyImported? */ true, /* default import? */ false);
                    }
                    var typesToExport = [];
                    if (!exportDecl.exportClause) {
                        // export * from '...'
                        // Resolve the * into all value symbols exported, and update the export declaration.
                        // Explicitly spelled out exports (i.e. the exports of the current module) take precedence
                        // over implicit ones from export *. Use the current module's exports to filter.
                        var currentModuleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
                        var currentModuleExports = currentModuleSymbol && currentModuleSymbol.exports;
                        if (!importedModuleSymbol) {
                            moduleTypeTranslator.error(exportDecl, "export * without module symbol");
                            return exportDecl;
                        }
                        var exportedSymbols = typeChecker.getExportsOfModule(importedModuleSymbol);
                        var exportSpecifiers = [];
                        try {
                            for (var exportedSymbols_1 = __values(exportedSymbols), exportedSymbols_1_1 = exportedSymbols_1.next(); !exportedSymbols_1_1.done; exportedSymbols_1_1 = exportedSymbols_1.next()) {
                                var sym = exportedSymbols_1_1.value;
                                if (currentModuleExports && currentModuleExports.has(sym.escapedName))
                                    continue;
                                // We might have already generated an export for the given symbol.
                                if (expandedStarImports.has(sym.name))
                                    continue;
                                expandedStarImports.add(sym.name);
                                // Only create an export specifier for values that are exported. For types, the code
                                // below creates specific export statements that match Closure's expectations.
                                if (shouldEmitValueExportForSymbol(sym)) {
                                    exportSpecifiers.push(ts.createExportSpecifier(undefined, sym.name));
                                }
                                else {
                                    typesToExport.push([sym.name, sym]);
                                }
                            }
                        }
                        catch (e_6_1) { e_6 = { error: e_6_1 }; }
                        finally {
                            try {
                                if (exportedSymbols_1_1 && !exportedSymbols_1_1.done && (_a = exportedSymbols_1.return)) _a.call(exportedSymbols_1);
                            }
                            finally { if (e_6) throw e_6.error; }
                        }
                        exportDecl = ts.updateExportDeclaration(exportDecl, exportDecl.decorators, exportDecl.modifiers, ts.createNamedExports(exportSpecifiers), exportDecl.moduleSpecifier);
                    }
                    else {
                        try {
                            for (var _d = __values(exportDecl.exportClause.elements), _e = _d.next(); !_e.done; _e = _d.next()) {
                                var exp = _e.value;
                                var exportedName = transformerUtil.getIdentifierText(exp.name);
                                typesToExport.push([exportedName, moduleTypeTranslator.mustGetSymbolAtLocation(exp.name)]);
                            }
                        }
                        catch (e_7_1) { e_7 = { error: e_7_1 }; }
                        finally {
                            try {
                                if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                            }
                            finally { if (e_7) throw e_7.error; }
                        }
                    }
                    // Do not emit typedef re-exports in untyped mode.
                    if (host.untyped)
                        return exportDecl;
                    var result = [exportDecl];
                    try {
                        for (var typesToExport_1 = __values(typesToExport), typesToExport_1_1 = typesToExport_1.next(); !typesToExport_1_1.done; typesToExport_1_1 = typesToExport_1.next()) {
                            var _f = __read(typesToExport_1_1.value, 2), exportedName = _f[0], sym = _f[1];
                            var aliasedSymbol = sym;
                            if (sym.flags & ts.SymbolFlags.Alias) {
                                aliasedSymbol = typeChecker.getAliasedSymbol(sym);
                            }
                            var isTypeAlias = (aliasedSymbol.flags & ts.SymbolFlags.Value) === 0 &&
                                (aliasedSymbol.flags & (ts.SymbolFlags.TypeAlias | ts.SymbolFlags.Interface)) !== 0;
                            if (!isTypeAlias)
                                continue;
                            var typeName = moduleTypeTranslator.symbolsToAliasedNames.get(aliasedSymbol) || aliasedSymbol.name;
                            var stmt = ts.createStatement(ts.createPropertyAccess(ts.createIdentifier('exports'), exportedName));
                            addCommentOn(stmt, [{ tagName: 'typedef', type: '!' + typeName }]);
                            ts.addSyntheticTrailingComment(stmt, ts.SyntaxKind.SingleLineCommentTrivia, ' re-export typedef', true);
                            result.push(stmt);
                        }
                    }
                    catch (e_8_1) { e_8 = { error: e_8_1 }; }
                    finally {
                        try {
                            if (typesToExport_1_1 && !typesToExport_1_1.done && (_c = typesToExport_1.return)) _c.call(typesToExport_1);
                        }
                        finally { if (e_8) throw e_8.error; }
                    }
                    return result;
                }
                /**
                 * Returns the identifiers exported in a single exported statement - typically just one
                 * identifier (e.g. for `export function foo()`), but multiple for `export declare var a, b`.
                 */
                function getExportDeclarationNames(node) {
                    switch (node.kind) {
                        case ts.SyntaxKind.VariableStatement:
                            var varDecl = node;
                            return varDecl.declarationList.declarations.map(function (d) { return getExportDeclarationNames(d)[0]; });
                        case ts.SyntaxKind.VariableDeclaration:
                        case ts.SyntaxKind.FunctionDeclaration:
                        case ts.SyntaxKind.InterfaceDeclaration:
                        case ts.SyntaxKind.ClassDeclaration:
                        case ts.SyntaxKind.ModuleDeclaration:
                        case ts.SyntaxKind.EnumDeclaration:
                            var decl = node;
                            if (!decl.name || decl.name.kind !== ts.SyntaxKind.Identifier) {
                                break;
                            }
                            return [decl.name];
                        case ts.SyntaxKind.TypeAliasDeclaration:
                            var typeAlias = node;
                            return [typeAlias.name];
                        default:
                            break;
                    }
                    moduleTypeTranslator.error(node, "unsupported export declaration " + ts.SyntaxKind[node.kind] + ": " + node.getText());
                    return [];
                }
                /**
                 * Ambient declarations declare types for TypeScript's benefit, and will be removede by
                 * TypeScript during its emit phase. Downstream Closure code however might be importing
                 * symbols from this module, so tsickle must emit a Closure-compatible exports declaration.
                 */
                function visitExportedAmbient(node) {
                    var e_9, _a;
                    if (host.untyped || !shouldEmitExportsAssignments())
                        return [node];
                    var declNames = getExportDeclarationNames(node);
                    var result = [node];
                    try {
                        for (var declNames_1 = __values(declNames), declNames_1_1 = declNames_1.next(); !declNames_1_1.done; declNames_1_1 = declNames_1.next()) {
                            var decl = declNames_1_1.value;
                            var sym = typeChecker.getSymbolAtLocation(decl);
                            var isValue = sym.flags & ts.SymbolFlags.Value;
                            // Non-value objects do not exist at runtime, so we cannot access the symbol (it only
                            // exists in externs). Export them as a typedef, which forwards to the type in externs.
                            // Note: TypeScript emits odd code for exported ambients (exports.x for variables, just x
                            // for everything else). That seems buggy, and in either case this code should not attempt
                            // to fix it.
                            // See also https://github.com/Microsoft/TypeScript/issues/8015.
                            if (!isValue) {
                                // Do not emit re-exports for ModuleDeclarations.
                                // Ambient ModuleDeclarations are always referenced as global symbols, so they don't
                                // need to be exported.
                                if (node.kind === ts.SyntaxKind.ModuleDeclaration)
                                    continue;
                                var mangledName = externs_1.moduleNameAsIdentifier(host, sourceFile.fileName);
                                var declName = transformerUtil.getIdentifierText(decl);
                                var stmt = ts.createStatement(ts.createPropertyAccess(ts.createIdentifier('exports'), declName));
                                addCommentOn(stmt, [{ tagName: 'typedef', type: "!" + mangledName + "." + declName }]);
                                result.push(stmt);
                            }
                        }
                    }
                    catch (e_9_1) { e_9 = { error: e_9_1 }; }
                    finally {
                        try {
                            if (declNames_1_1 && !declNames_1_1.done && (_a = declNames_1.return)) _a.call(declNames_1);
                        }
                        finally { if (e_9) throw e_9.error; }
                    }
                    return result;
                }
                function visitor(node) {
                    if (isAmbient(node)) {
                        if (!transformerUtil.hasModifierFlag(node, ts.ModifierFlags.Export)) {
                            return node;
                        }
                        return visitExportedAmbient(node);
                    }
                    switch (node.kind) {
                        case ts.SyntaxKind.ImportDeclaration:
                            return visitImportDeclaration(node);
                        case ts.SyntaxKind.ExportDeclaration:
                            return visitExportDeclaration(node);
                        case ts.SyntaxKind.ClassDeclaration:
                            return visitClassDeclaration(node);
                        case ts.SyntaxKind.InterfaceDeclaration:
                            return visitInterfaceDeclaration(node);
                        case ts.SyntaxKind.HeritageClause:
                            return visitHeritageClause(node);
                        case ts.SyntaxKind.Constructor:
                        case ts.SyntaxKind.FunctionDeclaration:
                        case ts.SyntaxKind.MethodDeclaration:
                        case ts.SyntaxKind.GetAccessor:
                        case ts.SyntaxKind.SetAccessor:
                            return visitFunctionLikeDeclaration(node);
                        case ts.SyntaxKind.ThisKeyword:
                            return visitThisExpression(node);
                        case ts.SyntaxKind.VariableStatement:
                            return visitVariableStatement(node);
                        case ts.SyntaxKind.PropertyDeclaration:
                        case ts.SyntaxKind.PropertyAssignment:
                            escapeIllegalJSDoc(node);
                            break;
                        case ts.SyntaxKind.Parameter:
                            // Parameter properties (e.g. `constructor(/** docs */ private foo: string)`) might have
                            // JSDoc comments, including JSDoc tags recognized by Closure Compiler. Prevent emitting
                            // any comments on them, so that Closure doesn't error on them.
                            // See test_files/parameter_properties.ts.
                            var paramDecl = node;
                            if (transformerUtil.hasModifierFlag(paramDecl, ts.ModifierFlags.ParameterPropertyModifier)) {
                                ts.setSyntheticLeadingComments(paramDecl, []);
                                jsdoc.suppressLeadingCommentsRecursively(paramDecl);
                            }
                            break;
                        case ts.SyntaxKind.TypeAliasDeclaration:
                            return visitTypeAliasDeclaration(node);
                        case ts.SyntaxKind.AsExpression:
                        case ts.SyntaxKind.TypeAssertionExpression:
                            return visitAssertionExpression(node);
                        case ts.SyntaxKind.NonNullExpression:
                            return visitNonNullExpression(node);
                        default:
                            break;
                    }
                    return ts.visitEachChild(node, visitor, context);
                }
                sourceFile = ts.visitEachChild(sourceFile, visitor, context);
                return moduleTypeTranslator.insertForwardDeclares(sourceFile);
            };
        };
    }
    exports.jsdocTransformer = jsdocTransformer;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNkb2NfdHJhbnNmb3JtZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvanNkb2NfdHJhbnNmb3JtZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFSDs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0JHO0lBRUgscURBQW1EO0lBQ25ELCtDQUFpRDtJQUNqRCxtREFBMkM7SUFDM0MseUNBQWlDO0lBQ2pDLDZFQUE4RDtJQUM5RCw4REFBc0Q7SUFDdEQsK0RBQTZEO0lBQzdELDJDQUFtQztJQXVDbkMsc0JBQXNCLElBQWEsRUFBRSxJQUFpQixFQUFFLGVBQTZCO1FBQ25GLElBQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFDbEUsSUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLDJCQUEyQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUM1RCxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3ZCLEVBQUUsQ0FBQywyQkFBMkIsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDL0MsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVELGdFQUFnRTtJQUNoRSxtQkFBMEIsSUFBYTtRQUNyQyxJQUFJLE9BQU8sR0FBc0IsSUFBSSxDQUFDO1FBQ3RDLE9BQU8sT0FBTyxFQUFFO1lBQ2QsSUFBSSxlQUFlLENBQUMsZUFBZSxDQUFDLE9BQXlCLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDeEYsT0FBTyxJQUFJLENBQUM7YUFDYjtZQUNELE9BQU8sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO1NBQzFCO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBVEQsOEJBU0M7SUFLRCx3RUFB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bkQsQ0FBQztnQkFFRCxVQUFVLEdBQUcsRUFBRSxDQUFDLGNBQWMsQ0FBQyxVQUFVLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUU3RCxPQUFPLG9CQUFvQixDQUFDLHFCQUFxQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2hFLENBQUMsQ0FBQztRQUNKLENBQUMsQ0FBQztJQUNKLENBQUM7SUEzaUJELDRDQTJpQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBqc2RvY190cmFuc2Zvcm1lciBjb250YWlucyB0aGUgbG9naWMgdG8gYWRkIEpTRG9jIGNvbW1lbnRzIHRvIFR5cGVTY3JpcHQgY29kZS5cbiAqXG4gKiBPbmUgb2YgdHNpY2tsZSdzIGZlYXR1cmVzIGlzIHRvIGFkZCBDbG9zdXJlIENvbXBpbGVyIGNvbXBhdGlibGUgSlNEb2MgY29tbWVudHMgY29udGFpbmluZyB0eXBlXG4gKiBhbm5vdGF0aW9ucywgaW5oZXJpdGFuY2UgaW5mb3JtYXRpb24sIGV0Yy4sIG9udG8gVHlwZVNjcmlwdCBjb2RlLiBUaGlzIGFsbG93cyBDbG9zdXJlIENvbXBpbGVyIHRvXG4gKiBtYWtlIGJldHRlciBvcHRpbWl6YXRpb24gZGVjaXNpb25zIGNvbXBhcmVkIHRvIGFuIHVudHlwZWQgY29kZSBiYXNlLlxuICpcbiAqIFRoZSBlbnRyeSBwb2ludCB0byB0aGUgYW5ub3RhdGlvbiBvcGVyYXRpb24gaXMganNkb2NUcmFuc2Zvcm1lciBiZWxvdy4gSXQgYWRkcyBzeW50aGV0aWMgY29tbWVudHNcbiAqIHRvIGV4aXN0aW5nIFR5cGVTY3JpcHQgY29uc3RydWN0cywgZm9yIGV4YW1wbGU6XG4gKiAgICAgY29uc3QgeDogbnVtYmVyID0gMTtcbiAqIE1pZ2h0IGdldCB0cmFuc2Zvcm1lZCB0bzpcbiAqICAgICAvLi4gXFxAdHlwZSB7bnVtYmVyfSAuL1xuICogICAgIGNvbnN0IHg6IG51bWJlciA9IDE7XG4gKiBMYXRlciBUeXBlU2NyaXB0IHBoYXNlcyB0aGVuIHJlbW92ZSB0aGUgdHlwZSBhbm5vdGF0aW9uLCBhbmQgdGhlIGZpbmFsIGVtaXQgaXMgSmF2YVNjcmlwdCB0aGF0XG4gKiBvbmx5IGNvbnRhaW5zIHRoZSBKU0RvYyBjb21tZW50LlxuICpcbiAqIFRvIGhhbmRsZSBjZXJ0YWluIGNvbnN0cnVjdHMsIHRoaXMgdHJhbnNmb3JtZXIgYWxzbyBwZXJmb3JtcyBBU1QgdHJhbnNmb3JtYXRpb25zLCBlLmcuIGJ5IGFkZGluZ1xuICogQ29tbW9uSlMtc3R5bGUgZXhwb3J0cyBmb3IgdHlwZSBjb25zdHJ1Y3RzLCBleHBhbmRpbmcgYGV4cG9ydCAqYCwgcGFyZW50aGVzaXppbmcgY2FzdHMsIGV0Yy5cbiAqL1xuXG5pbXBvcnQge2hhc0V4cG9ydGluZ0RlY29yYXRvcn0gZnJvbSAnLi9kZWNvcmF0b3JzJztcbmltcG9ydCB7bW9kdWxlTmFtZUFzSWRlbnRpZmllcn0gZnJvbSAnLi9leHRlcm5zJztcbmltcG9ydCAqIGFzIGdvb2dtb2R1bGUgZnJvbSAnLi9nb29nbW9kdWxlJztcbmltcG9ydCAqIGFzIGpzZG9jIGZyb20gJy4vanNkb2MnO1xuaW1wb3J0IHtNb2R1bGVUeXBlVHJhbnNsYXRvcn0gZnJvbSAnLi9tb2R1bGVfdHlwZV90cmFuc2xhdG9yJztcbmltcG9ydCAqIGFzIHRyYW5zZm9ybWVyVXRpbCBmcm9tICcuL3RyYW5zZm9ybWVyX3V0aWwnO1xuaW1wb3J0IHtpc1ZhbGlkQ2xvc3VyZVByb3BlcnR5TmFtZX0gZnJvbSAnLi90eXBlX3RyYW5zbGF0b3InO1xuaW1wb3J0ICogYXMgdHMgZnJvbSAnLi90eXBlc2NyaXB0JztcblxuLyoqIEFubm90YXRvckhvc3QgY29udGFpbnMgaG9zdCBwcm9wZXJ0aWVzIGZvciB0aGUgSlNEb2MtYW5ub3RhdGlvbiBwcm9jZXNzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBBbm5vdGF0b3JIb3N0IHtcbiAgLyoqXG4gICAqIElmIHByb3ZpZGVkIGEgZnVuY3Rpb24gdGhhdCBsb2dzIGFuIGludGVybmFsIHdhcm5pbmcuXG4gICAqIFRoZXNlIHdhcm5pbmdzIGFyZSBub3QgYWN0aW9uYWJsZSBieSBhbiBlbmQgdXNlciBhbmQgc2hvdWxkIGJlIGhpZGRlblxuICAgKiBieSBkZWZhdWx0LlxuICAgKi9cbiAgbG9nV2FybmluZz86ICh3YXJuaW5nOiB0cy5EaWFnbm9zdGljKSA9PiB2b2lkO1xuICBwYXRoVG9Nb2R1bGVOYW1lOiAoY29udGV4dDogc3RyaW5nLCBpbXBvcnRQYXRoOiBzdHJpbmcpID0+IHN0cmluZztcbiAgLyoqXG4gICAqIElmIHRydWUsIGNvbnZlcnQgZXZlcnkgdHlwZSB0byB0aGUgQ2xvc3VyZSB7P30gdHlwZSwgd2hpY2ggbWVhbnNcbiAgICogXCJkb24ndCBjaGVjayB0eXBlc1wiLlxuICAgKi9cbiAgdW50eXBlZD86IGJvb2xlYW47XG4gIC8qKiBJZiBwcm92aWRlZCwgYSBzZXQgb2YgcGF0aHMgd2hvc2UgdHlwZXMgc2hvdWxkIGFsd2F5cyBnZW5lcmF0ZSBhcyB7P30uICovXG4gIHR5cGVCbGFja0xpc3RQYXRocz86IFNldDxzdHJpbmc+O1xuICAvKipcbiAgICogQ29udmVydCBzaG9ydGhhbmQgXCIvaW5kZXhcIiBpbXBvcnRzIHRvIGZ1bGwgcGF0aCAoaW5jbHVkZSB0aGUgXCIvaW5kZXhcIikuXG4gICAqIEFubm90YXRpb24gd2lsbCBiZSBzbG93ZXIgYmVjYXVzZSBldmVyeSBpbXBvcnQgbXVzdCBiZSByZXNvbHZlZC5cbiAgICovXG4gIGNvbnZlcnRJbmRleEltcG9ydFNob3J0aGFuZD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBJZiB0cnVlLCBtb2RpZnkgcXVvdGVzIGFyb3VuZCBwcm9wZXJ0eSBhY2Nlc3NvcnMgdG8gbWF0Y2ggdGhlIHR5cGUgZGVjbGFyYXRpb24uXG4gICAqL1xuICBlbmFibGVBdXRvUXVvdGluZz86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRzaWNrbGUgc2hvdWxkIGluc2VydCBnb29nLnByb3ZpZGUoKSBjYWxscyBpbnRvIHRoZSBleHRlcm5zIGdlbmVyYXRlZCBmb3IgYC5kLnRzYCBmaWxlc1xuICAgKiB0aGF0IGFyZSBleHRlcm5hbCBtb2R1bGVzLlxuICAgKi9cbiAgcHJvdmlkZUV4dGVybmFsTW9kdWxlRHRzTmFtZXNwYWNlPzogYm9vbGVhbjtcblxuICAvKiogaG9zdCBhbGxvd3MgcmVzb2x2aW5nIGZpbGUgbmFtZXMgdG8gbW9kdWxlcy4gKi9cbiAgaG9zdDogdHMuTW9kdWxlUmVzb2x1dGlvbkhvc3Q7XG4gIC8qKiBVc2VkIHRvZ2V0aGVyIHdpdGggdGhlIGhvc3QgZm9yIGZpbGUgbmFtZSAtPiBtb2R1bGUgbmFtZSByZXNvbHV0aW9uLiAqL1xuICBvcHRpb25zOiB0cy5Db21waWxlck9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGFkZENvbW1lbnRPbihub2RlOiB0cy5Ob2RlLCB0YWdzOiBqc2RvYy5UYWdbXSwgZXNjYXBlRXh0cmFUYWdzPzogU2V0PHN0cmluZz4pIHtcbiAgY29uc3QgY29tbWVudCA9IGpzZG9jLnRvU3ludGhlc2l6ZWRDb21tZW50KHRhZ3MsIGVzY2FwZUV4dHJhVGFncyk7XG4gIGNvbnN0IGNvbW1lbnRzID0gdHMuZ2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKG5vZGUpIHx8IFtdO1xuICBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICB0cy5zZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHMobm9kZSwgY29tbWVudHMpO1xuICByZXR1cm4gY29tbWVudDtcbn1cblxuLyoqIEByZXR1cm4gdHJ1ZSBpZiBub2RlIGhhcyB0aGUgc3BlY2lmaWVkIG1vZGlmaWVyIGZsYWcgc2V0LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQW1iaWVudChub2RlOiB0cy5Ob2RlKTogYm9vbGVhbiB7XG4gIGxldCBjdXJyZW50OiB0cy5Ob2RlfHVuZGVmaW5lZCA9IG5vZGU7XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgaWYgKHRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcoY3VycmVudCBhcyB0cy5EZWNsYXJhdGlvbiwgdHMuTW9kaWZpZXJGbGFncy5BbWJpZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnR5cGUgSGFzVHlwZVBhcmFtZXRlcnMgPVxuICAgIHRzLkludGVyZmFjZURlY2xhcmF0aW9ufHRzLkNsYXNzTGlrZURlY2xhcmF0aW9ufHRzLlR5cGVBbGlhc0RlY2xhcmF0aW9ufHRzLlNpZ25hdHVyZURlY2xhcmF0aW9uO1xuXG4vKiogQWRkcyBhbiBcXEB0ZW1wbGF0ZSBjbGF1c2UgdG8gZG9jVGFncyBpZiBkZWNsIGhhcyB0eXBlIHBhcmFtZXRlcnMuICovXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVBZGRUZW1wbGF0ZUNsYXVzZShkb2NUYWdzOiBqc2RvYy5UYWdbXSwgZGVjbDogSGFzVHlwZVBhcmFtZXRlcnMpIHtcbiAgaWYgKCFkZWNsLnR5cGVQYXJhbWV0ZXJzKSByZXR1cm47XG4gIC8vIENsb3N1cmUgZG9lcyBub3Qgc3VwcG9ydCB0ZW1wbGF0ZSBjb25zdHJhaW50cyAoVCBleHRlbmRzIFgpLCB0aGVzZSBhcmUgaWdub3JlZCBiZWxvdy5cbiAgZG9jVGFncy5wdXNoKHtcbiAgICB0YWdOYW1lOiAndGVtcGxhdGUnLFxuICAgIHRleHQ6IGRlY2wudHlwZVBhcmFtZXRlcnMubWFwKHRwID0+IHRyYW5zZm9ybWVyVXRpbC5nZXRJZGVudGlmaWVyVGV4dCh0cC5uYW1lKSkuam9pbignLCAnKVxuICB9KTtcbn1cblxuLyoqXG4gKiBBZGRzIGhlcml0YWdlIGNsYXVzZXMgKFxcQGV4dGVuZHMsIFxcQGltcGxlbWVudHMpIHRvIHRoZSBnaXZlbiBkb2NUYWdzIGZvciBkZWNsLiBVc2VkIGJ5XG4gKiBqc2RvY190cmFuc2Zvcm1lciBhbmQgZXh0ZXJucyBnZW5lcmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVBZGRIZXJpdGFnZUNsYXVzZXMoXG4gICAgZG9jVGFnczoganNkb2MuVGFnW10sIG10dDogTW9kdWxlVHlwZVRyYW5zbGF0b3IsXG4gICAgZGVjbDogdHMuQ2xhc3NMaWtlRGVjbGFyYXRpb258dHMuSW50ZXJmYWNlRGVjbGFyYXRpb24pIHtcbiAgaWYgKCFkZWNsLmhlcml0YWdlQ2xhdXNlcykgcmV0dXJuO1xuICBjb25zdCBpc0NsYXNzID0gZGVjbC5raW5kID09PSB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb247XG4gIGNvbnN0IGhhc0V4dGVuZHMgPSBkZWNsLmhlcml0YWdlQ2xhdXNlcy5zb21lKGMgPT4gYy50b2tlbiA9PT0gdHMuU3ludGF4S2luZC5FeHRlbmRzS2V5d29yZCk7XG4gIGZvciAoY29uc3QgaGVyaXRhZ2Ugb2YgZGVjbC5oZXJpdGFnZUNsYXVzZXMpIHtcbiAgICBjb25zdCBpc0V4dGVuZHMgPSBoZXJpdGFnZS50b2tlbiA9PT0gdHMuU3ludGF4S2luZC5FeHRlbmRzS2V5d29yZDtcbiAgICBpZiAoaXNDbGFzcyAmJiBpc0V4dGVuZHMpIHtcbiAgICAgIC8vIElmIGEgY2xhc3MgaGFzIGFuIFwiZXh0ZW5kc1wiLCB0aGF0IGlzIHByZXNlcnZlZCBpbiB0aGUgRVM2IG91dHB1dFxuICAgICAgLy8gYW5kIHdlIGRvbid0IG5lZWQgdG8gZW1pdCBhbnkgYWRkaXRpb25hbCBqc2RvYy5cbiAgICAgIC8vXG4gICAgICAvLyBIb3dldmVyIGZvciBhbWJpZW50IGRlY2xhcmF0aW9ucywgd2Ugb25seSBlbWl0IGV4dGVybnMsIGFuZCBpbiB0aG9zZSB3ZSBkbyBuZWVkIHRvXG4gICAgICAvLyBhZGQgXCJAZXh0ZW5kcyB7Rm9vfVwiIGFzIHRoZXkgdXNlIEVTNSBzeW50YXguXG4gICAgICBpZiAoIWlzQW1iaWVudChkZWNsKSkgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSBnZXQgaGVyZSwgd2UgbmVlZCB0byBlbWl0IHNvbWUganNkb2MuXG4gICAgZm9yIChjb25zdCBleHByIG9mIGhlcml0YWdlLnR5cGVzKSB7XG4gICAgICBjb25zdCBoZXJpdGFnZSA9IGhlcml0YWdlTmFtZShpc0V4dGVuZHMsIGhhc0V4dGVuZHMsIGV4cHIpO1xuICAgICAgLy8gaGVyaXRhZ2VOYW1lIG1heSByZXR1cm4gbnVsbCwgaW5kaWNhdGluZyB0aGF0IHRoZSBjbGF1c2UgaXMgc29tZXRoaW5nIGluZXhwcmVzc2libGVcbiAgICAgIC8vIGluIENsb3N1cmUsIGUuZy4gXCJjbGFzcyBGb28gaW1wbGVtZW50cyBQYXJ0aWFsPEJhcj5cIi5cbiAgICAgIGlmICghaGVyaXRhZ2UpIHtcbiAgICAgICAgLy8gRm9yICdleHRlbmRzJyBjbGF1c2VzIHRoYXQgbWVhbnMgd2UgY2Fubm90IGVtaXQgYW55dGhpbmcgYXQgYWxsLlxuICAgICAgICBpZiAoIWlzRXh0ZW5kcykge1xuICAgICAgICAgIGRvY1RhZ3MucHVzaCh7XG4gICAgICAgICAgICB0YWdOYW1lOiBpc0V4dGVuZHMgPyAnZXh0ZW5kcycgOiAnaW1wbGVtZW50cycsXG4gICAgICAgICAgICB0eXBlOiAnSW5leHByZXNzaWJsZVR5cGUnLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2NUYWdzLnB1c2goe1xuICAgICAgICAgIHRhZ05hbWU6IGhlcml0YWdlLnRhZ05hbWUsXG4gICAgICAgICAgdHlwZTogaGVyaXRhZ2UucGFyZW50TmFtZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBDbG9zdXJlIG5hbWUgb2YgYW4gZXhwcmVzc2lvbiBvY2N1cnJpbmcgaW4gYSBoZXJpdGFnZSBjbGF1c2UsXG4gICAqIGUuZy4gXCJpbXBsZW1lbnRzIEZvb0JhclwiLiAgV2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgZXhwcmVzc2lvbiBpcyBpbmV4cHJlc3NpYmxlXG4gICAqIGluIENsb3N1cmUgc2VtYW50aWNzLiAgTm90ZSB0aGF0IHdlIGRvbid0IG5lZWQgdG8gY29uc2lkZXIgYWxsIHBvc3NpYmxlXG4gICAqIGNvbWJpbmF0aW9ucyBvZiB0eXBlcy92YWx1ZXMgYW5kIGV4dGVuZHMvaW1wbGVtZW50cyBiZWNhdXNlIG91ciBpbnB1dCBpc1xuICAgKiBhbHJlYWR5IHZlcmlmaWVkIHRvIGJlIHZhbGlkIFR5cGVTY3JpcHQuICBTZWUgdGVzdF9maWxlcy9jbGFzcy8gZm9yIHRoZSBmdWxsXG4gICAqIGNhcnRlc2lhbiBwcm9kdWN0IG9mIHRlc3QgY2FzZXMuXG4gICAqIEBwYXJhbSBpc0V4dGVuZHMgVHJ1ZSBpZiB3ZSdyZSBpbiBhbiAnZXh0ZW5kcycsIGZhbHNlIGluIGFuICdpbXBsZW1lbnRzJy5cbiAgICogQHBhcmFtIGhhc0V4dGVuZHMgVHJ1ZSBpZiB0aGVyZSBhcmUgYW55ICdleHRlbmRzJyBjbGF1c2VzIHByZXNlbnQgYXQgYWxsLlxuICAgKi9cbiAgZnVuY3Rpb24gaGVyaXRhZ2VOYW1lKFxuICAgICAgaXNFeHRlbmRzOiBib29sZWFuLCBoYXNFeHRlbmRzOiBib29sZWFuLFxuICAgICAgZXhwcjogdHMuRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzKToge3RhZ05hbWU6IHN0cmluZywgcGFyZW50TmFtZTogc3RyaW5nfXxudWxsIHtcbiAgICBsZXQgdGFnTmFtZSA9IGlzRXh0ZW5kcyA/ICdleHRlbmRzJyA6ICdpbXBsZW1lbnRzJztcbiAgICBsZXQgc3ltID0gbXR0LnR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oZXhwci5leHByZXNzaW9uKTtcbiAgICBpZiAoIXN5bSkge1xuICAgICAgLy8gSXQncyBwb3NzaWJsZSBmb3IgYSBjbGFzcyBkZWNsYXJhdGlvbiB0byBleHRlbmQgYW4gZXhwcmVzc2lvbiB0aGF0XG4gICAgICAvLyBkb2VzIG5vdCBoYXZlIGhhdmUgYSBzeW1ib2wsIGZvciBleGFtcGxlIHdoZW4gYSBtaXhpbiBmdW5jdGlvbiBpc1xuICAgICAgLy8gdXNlZCB0byBidWlsZCBhIGJhc2UgY2xhc3MsIGFzIGluIGBkZWNsYXJlIE15Q2xhc3MgZXh0ZW5kc1xuICAgICAgLy8gTXlNaXhpbihNeUJhc2VDbGFzcylgLlxuICAgICAgLy9cbiAgICAgIC8vIEhhbmRsaW5nIHRoaXMgY29ycmVjdGx5IGlzIHRyaWNreS4gQ2xvc3VyZSB0aHJvd3Mgb24gdGhpc1xuICAgICAgLy8gYGV4dGVuZHMgPGV4cHJlc3Npb24+YCBzeW50YXggKHNlZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8yMTgyKS4gV2Ugd291bGRcbiAgICAgIC8vIHByb2JhYmx5IG5lZWQgdG8gZ2VuZXJhdGUgYW4gaW50ZXJtZWRpYXRlIGNsYXNzIGRlY2xhcmF0aW9uIGFuZFxuICAgICAgLy8gZXh0ZW5kIHRoYXQuXG4gICAgICBtdHQuZGVidWdXYXJuKGRlY2wsIGBjb3VsZCBub3QgcmVzb2x2ZSBzdXBlcnR5cGU6ICR7ZXhwci5nZXRUZXh0KCl9YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBSZXNvbHZlIGFueSBhbGlhc2VzIHRvIHRoZSB1bmRlcmx5aW5nIHR5cGUuXG4gICAgaWYgKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlR5cGVBbGlhcykge1xuICAgICAgLy8gSXQncyBpbXBsZW1lbnRpbmcgYSB0eXBlIGFsaWFzLiAgRm9sbG93IHRoZSB0eXBlIGFsaWFzIGJhY2tcbiAgICAgIC8vIHRvIHRoZSBvcmlnaW5hbCBzeW1ib2wgdG8gY2hlY2sgd2hldGhlciBpdCdzIGEgdHlwZSBvciBhIHZhbHVlLlxuICAgICAgY29uc3QgdHlwZSA9IG10dC50eXBlQ2hlY2tlci5nZXREZWNsYXJlZFR5cGVPZlN5bWJvbChzeW0pO1xuICAgICAgaWYgKCF0eXBlLnN5bWJvbCkge1xuICAgICAgICAvLyBJdCdzIG5vdCBjbGVhciB3aGVuIHRoaXMgY2FuIGhhcHBlbi5cbiAgICAgICAgbXR0LmRlYnVnV2FybihkZWNsLCBgY291bGQgbm90IGdldCB0eXBlIG9mIHN5bWJvbDogJHtleHByLmdldFRleHQoKX1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBzeW0gPSB0eXBlLnN5bWJvbDtcbiAgICB9XG4gICAgaWYgKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkFsaWFzKSB7XG4gICAgICBzeW0gPSBtdHQudHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChzeW0pO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGVUcmFuc2xhdG9yID0gbXR0Lm5ld1R5cGVUcmFuc2xhdG9yKGV4cHIuZXhwcmVzc2lvbik7XG4gICAgaWYgKHR5cGVUcmFuc2xhdG9yLmlzQmxhY2tMaXN0ZWQoc3ltKSkge1xuICAgICAgLy8gRG9uJ3QgZW1pdCByZWZlcmVuY2VzIHRvIGJsYWNrbGlzdGVkIHR5cGVzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkNsYXNzKSB7XG4gICAgICBpZiAoIWlzQ2xhc3MpIHtcbiAgICAgICAgLy8gQ2xvc3VyZSBpbnRlcmZhY2VzIGNhbm5vdCBleHRlbmQgb3IgaW1wbGVtZW50cyBjbGFzc2VzLlxuICAgICAgICBtdHQuZGVidWdXYXJuKGRlY2wsIGBvbWl0dGluZyBpbnRlcmZhY2UgZGVyaXZpbmcgZnJvbSBjbGFzczogJHtleHByLmdldFRleHQoKX1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRXh0ZW5kcykge1xuICAgICAgICBpZiAoIWhhc0V4dGVuZHMpIHtcbiAgICAgICAgICAvLyBBIHNwZWNpYWwgY2FzZTogZm9yIGEgY2xhc3MgdGhhdCBoYXMgbm8gZXhpc3RpbmcgJ2V4dGVuZHMnIGNsYXVzZSBidXQgZG9lc1xuICAgICAgICAgIC8vIGhhdmUgYW4gJ2ltcGxlbWVudHMnIGNsYXVzZSB0aGF0IHJlZmVycyB0byBhbm90aGVyIGNsYXNzLCB3ZSBjaGFuZ2UgaXQgdG9cbiAgICAgICAgICAvLyBpbnN0ZWFkIGJlIGFuICdleHRlbmRzJy4gIFRoaXMgd2FzIGEgcG9vcmx5LXRob3VnaHQtb3V0IGhhY2sgdGhhdCBtYXlcbiAgICAgICAgICAvLyBhY3R1YWxseSBjYXVzZSBjb21waWxlciBidWdzOlxuICAgICAgICAgIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8zMTI2XG4gICAgICAgICAgLy8gYnV0IHdlIGhhdmUgY29kZSB0aGF0IG5vdyByZWxpZXMgb24gaXQsIHVnaC5cbiAgICAgICAgICB0YWdOYW1lID0gJ2V4dGVuZHMnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENsb3N1cmUgY2FuIG9ubHkgQGltcGxlbWVudHMgYW4gaW50ZXJmYWNlLCBub3QgYSBjbGFzcy5cbiAgICAgICAgICBtdHQuZGVidWdXYXJuKGRlY2wsIGBvbWl0dGluZyBAaW1wbGVtZW50cyBvZiBhIGNsYXNzOiAke2V4cHIuZ2V0VGV4dCgpfWApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5WYWx1ZSkge1xuICAgICAgLy8gSWYgaXQncyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIGNsYXNzIGluIHRoZSB2YWx1ZSBuYW1lc3BhY2UsIHRoZW4gaXQgd2lsbFxuICAgICAgLy8gbm90IGJlIGEgdHlwZSBpbiB0aGUgQ2xvc3VyZSBvdXRwdXQgKGJlY2F1c2UgQ2xvc3VyZSBjb2xsYXBzZXNcbiAgICAgIC8vIHRoZSB0eXBlIGFuZCB2YWx1ZSBuYW1lc3BhY2VzKS5cbiAgICAgIG10dC5kZWJ1Z1dhcm4oXG4gICAgICAgICAgZGVjbCwgYG9taXR0aW5nIGhlcml0YWdlIHJlZmVyZW5jZSB0byBhIHR5cGUvdmFsdWUgY29uZmxpY3Q6ICR7ZXhwci5nZXRUZXh0KCl9YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlR5cGVMaXRlcmFsKSB7XG4gICAgICAvLyBBIHR5cGUgbGl0ZXJhbCBpcyBhIHR5cGUgbGlrZSBge2Zvbzogc3RyaW5nfWAuXG4gICAgICAvLyBUaGVzZSBjYW4gY29tZSB1cCBhcyB0aGUgb3V0cHV0IG9mIGEgbWFwcGVkIHR5cGUuXG4gICAgICBtdHQuZGVidWdXYXJuKGRlY2wsIGBvbWl0dGluZyBoZXJpdGFnZSByZWZlcmVuY2UgdG8gYSB0eXBlIGxpdGVyYWw6ICR7ZXhwci5nZXRUZXh0KCl9YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyB0eXBlVG9DbG9zdXJlIGluY2x1ZGVzIG51bGxhYmlsaXR5IG1vZGlmaWVycywgc28gY2FsbCBzeW1ib2xUb1N0cmluZyBkaXJlY3RseSBoZXJlLlxuICAgIGNvbnN0IHBhcmVudE5hbWUgPSB0eXBlVHJhbnNsYXRvci5zeW1ib2xUb1N0cmluZyhzeW0pO1xuICAgIGlmICghcGFyZW50TmFtZSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHt0YWdOYW1lLCBwYXJlbnROYW1lfTtcbiAgfVxufVxuXG4vKipcbiAqIGNyZWF0ZU1lbWJlclR5cGVEZWNsYXJhdGlvbiBlbWl0cyB0aGUgdHlwZSBhbm5vdGF0aW9ucyBmb3IgbWVtYmVycyBvZiBhIGNsYXNzLiBJdCdzIG5lY2Vzc2FyeSBpblxuICogdGhlIGNhc2Ugd2hlcmUgVHlwZVNjcmlwdCBzeW50YXggc3BlY2lmaWVzIHRoZXJlIGFyZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb24gdGhlIGNsYXNzLCBiZWNhdXNlXG4gKiB0byBkZWNsYXJlIHRoZXNlIGluIENsb3N1cmUgeW91IG11c3QgZGVjbGFyZSB0aGVzZSBzZXBhcmF0ZWx5IGZyb20gdGhlIGNsYXNzLlxuICpcbiAqIGNyZWF0ZU1lbWJlclR5cGVEZWNsYXJhdGlvbiBwcm9kdWNlcyBhbiBpZiAoZmFsc2UpIHN0YXRlbWVudCBjb250YWluaW5nIHByb3BlcnR5IGRlY2xhcmF0aW9ucywgb3JcbiAqIG51bGwgaWYgbm8gZGVjbGFyYXRpb25zIGNvdWxkIG9yIG5lZWRlZCB0byBiZSBnZW5lcmF0ZWQgKGUuZy4gbm8gbWVtYmVycywgb3IgYW4gdW5uYW1lZCB0eXBlKS5cbiAqIFRoZSBpZiBzdGF0ZW1lbnQgaXMgdXNlZCB0byBtYWtlIHN1cmUgdGhlIGNvZGUgaXMgbm90IGV4ZWN1dGVkLCBvdGhlcndpc2UgcHJvcGVydHkgYWNjZXNzZXMgY291bGRcbiAqIHRyaWdnZXIgZ2V0dGVycyBvbiBhIHN1cGVyY2xhc3MuIFNlZSB0ZXN0X2ZpbGVzL2ZpZWxkcy9maWVsZHMudHM6QmFzZVRoYXRUaHJvd3MuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1lbWJlclR5cGVEZWNsYXJhdGlvbihcbiAgICBtdHQ6IE1vZHVsZVR5cGVUcmFuc2xhdG9yLFxuICAgIHR5cGVEZWNsOiB0cy5DbGFzc0RlY2xhcmF0aW9ufHRzLkludGVyZmFjZURlY2xhcmF0aW9uKTogdHMuSWZTdGF0ZW1lbnR8bnVsbCB7XG4gIC8vIEdhdGhlciBwYXJhbWV0ZXIgcHJvcGVydGllcyBmcm9tIHRoZSBjb25zdHJ1Y3RvciwgaWYgaXQgZXhpc3RzLlxuICBjb25zdCBjdG9yczogdHMuQ29uc3RydWN0b3JEZWNsYXJhdGlvbltdID0gW107XG4gIGxldCBwYXJhbVByb3BzOiB0cy5QYXJhbWV0ZXJEZWNsYXJhdGlvbltdID0gW107XG4gIGNvbnN0IG5vblN0YXRpY1Byb3BzOiBBcnJheTx0cy5Qcm9wZXJ0eURlY2xhcmF0aW9ufHRzLlByb3BlcnR5U2lnbmF0dXJlPiA9IFtdO1xuICBjb25zdCBzdGF0aWNQcm9wczogQXJyYXk8dHMuUHJvcGVydHlEZWNsYXJhdGlvbnx0cy5Qcm9wZXJ0eVNpZ25hdHVyZT4gPSBbXTtcbiAgY29uc3QgdW5oYW5kbGVkOiB0cy5OYW1lZERlY2xhcmF0aW9uW10gPSBbXTtcbiAgY29uc3QgYWJzdHJhY3RNZXRob2RzOiB0cy5GdW5jdGlvbkxpa2VEZWNsYXJhdGlvbltdID0gW107XG4gIGZvciAoY29uc3QgbWVtYmVyIG9mIHR5cGVEZWNsLm1lbWJlcnMpIHtcbiAgICBpZiAobWVtYmVyLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3IpIHtcbiAgICAgIGN0b3JzLnB1c2gobWVtYmVyIGFzIHRzLkNvbnN0cnVjdG9yRGVjbGFyYXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHMuaXNQcm9wZXJ0eURlY2xhcmF0aW9uKG1lbWJlcikgfHwgdHMuaXNQcm9wZXJ0eVNpZ25hdHVyZShtZW1iZXIpKSB7XG4gICAgICBjb25zdCBpc1N0YXRpYyA9IHRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcobWVtYmVyLCB0cy5Nb2RpZmllckZsYWdzLlN0YXRpYyk7XG4gICAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgICAgc3RhdGljUHJvcHMucHVzaChtZW1iZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9uU3RhdGljUHJvcHMucHVzaChtZW1iZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIG1lbWJlci5raW5kID09PSB0cy5TeW50YXhLaW5kLk1ldGhvZERlY2xhcmF0aW9uIHx8XG4gICAgICAgIG1lbWJlci5raW5kID09PSB0cy5TeW50YXhLaW5kLk1ldGhvZFNpZ25hdHVyZSB8fFxuICAgICAgICBtZW1iZXIua2luZCA9PT0gdHMuU3ludGF4S2luZC5HZXRBY2Nlc3NvciB8fCBtZW1iZXIua2luZCA9PT0gdHMuU3ludGF4S2luZC5TZXRBY2Nlc3Nvcikge1xuICAgICAgaWYgKHRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcobWVtYmVyLCB0cy5Nb2RpZmllckZsYWdzLkFic3RyYWN0KSB8fFxuICAgICAgICAgIHRzLmlzSW50ZXJmYWNlRGVjbGFyYXRpb24odHlwZURlY2wpKSB7XG4gICAgICAgIGFic3RyYWN0TWV0aG9kcy5wdXNoKFxuICAgICAgICAgICAgbWVtYmVyIGFzIHRzLk1ldGhvZERlY2xhcmF0aW9uIHwgdHMuR2V0QWNjZXNzb3JEZWNsYXJhdGlvbiB8IHRzLlNldEFjY2Vzc29yRGVjbGFyYXRpb24pO1xuICAgICAgfVxuICAgICAgLy8gTm9uLWFic3RyYWN0IG1ldGhvZHMgb25seSBleGlzdCBvbiBjbGFzc2VzLCBhbmQgYXJlIGhhbmRsZWQgaW4gcmVndWxhciBlbWl0LlxuICAgIH0gZWxzZSB7XG4gICAgICB1bmhhbmRsZWQucHVzaChtZW1iZXIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgLy8gT25seSB0aGUgYWN0dWFsIGNvbnN0cnVjdG9yIGltcGxlbWVudGF0aW9uLCB3aGljaCBtdXN0IGJlIGxhc3QgaW4gYSBwb3RlbnRpYWwgc2VxdWVuY2Ugb2ZcbiAgICAvLyBvdmVybG9hZGVkIGNvbnN0cnVjdG9ycywgbWF5IGNvbnRhaW4gcGFyYW1ldGVyIHByb3BlcnRpZXMuXG4gICAgY29uc3QgY3RvciA9IGN0b3JzW2N0b3JzLmxlbmd0aCAtIDFdO1xuICAgIHBhcmFtUHJvcHMgPSBjdG9yLnBhcmFtZXRlcnMuZmlsdGVyKFxuICAgICAgICBwID0+IHRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcocCwgdHMuTW9kaWZpZXJGbGFncy5QYXJhbWV0ZXJQcm9wZXJ0eU1vZGlmaWVyKSk7XG4gIH1cblxuICBpZiAobm9uU3RhdGljUHJvcHMubGVuZ3RoID09PSAwICYmIHBhcmFtUHJvcHMubGVuZ3RoID09PSAwICYmIHN0YXRpY1Byb3BzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgYWJzdHJhY3RNZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIFRoZXJlIGFyZSBubyBtZW1iZXJzIHNvIHdlIGRvbid0IG5lZWQgdG8gZW1pdCBhbnkgdHlwZVxuICAgIC8vIGFubm90YXRpb25zIGhlbHBlci5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghdHlwZURlY2wubmFtZSkge1xuICAgIG10dC5kZWJ1Z1dhcm4odHlwZURlY2wsICdjYW5ub3QgYWRkIHR5cGVzIG9uIHVubmFtZWQgZGVjbGFyYXRpb25zJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBjbGFzc05hbWUgPSB0cmFuc2Zvcm1lclV0aWwuZ2V0SWRlbnRpZmllclRleHQodHlwZURlY2wubmFtZSk7XG4gIGNvbnN0IHN0YXRpY1Byb3BBY2Nlc3MgPSB0cy5jcmVhdGVJZGVudGlmaWVyKGNsYXNzTmFtZSk7XG4gIGNvbnN0IGluc3RhbmNlUHJvcEFjY2VzcyA9IHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKHN0YXRpY1Byb3BBY2Nlc3MsICdwcm90b3R5cGUnKTtcbiAgLy8gQ2xvc3VyZSBDb21waWxlciB3aWxsIHJlcG9ydCBjb25mb3JtYW5jZSBlcnJvcnMgYWJvdXQgdGhpcyBiZWluZyB1bmtub3duIHR5cGUgd2hlbiBlbWl0dGluZ1xuICAvLyBjbGFzcyBwcm9wZXJ0aWVzIGFzIHs/fHVuZGVmaW5lZH0sIGluc3RlYWQgb2YganVzdCB7P30uIFNvIG1ha2Ugc3VyZSB0byBvbmx5IGVtaXQgez98dW5kZWZpbmVkfVxuICAvLyBvbiBpbnRlcmZhY2VzLlxuICBjb25zdCBpc0ludGVyZmFjZSA9IHRzLmlzSW50ZXJmYWNlRGVjbGFyYXRpb24odHlwZURlY2wpO1xuICBjb25zdCBwcm9wZXJ0eURlY2xzID0gc3RhdGljUHJvcHMubWFwKFxuICAgICAgcCA9PiBjcmVhdGVDbG9zdXJlUHJvcGVydHlEZWNsYXJhdGlvbihcbiAgICAgICAgICBtdHQsIHN0YXRpY1Byb3BBY2Nlc3MsIHAsIGlzSW50ZXJmYWNlICYmICEhcC5xdWVzdGlvblRva2VuKSk7XG4gIHByb3BlcnR5RGVjbHMucHVzaCguLi5bLi4ubm9uU3RhdGljUHJvcHMsIC4uLnBhcmFtUHJvcHNdLm1hcChcbiAgICAgIHAgPT4gY3JlYXRlQ2xvc3VyZVByb3BlcnR5RGVjbGFyYXRpb24oXG4gICAgICAgICAgbXR0LCBpbnN0YW5jZVByb3BBY2Nlc3MsIHAsIGlzSW50ZXJmYWNlICYmICEhcC5xdWVzdGlvblRva2VuKSkpO1xuICBwcm9wZXJ0eURlY2xzLnB1c2goLi4udW5oYW5kbGVkLm1hcChcbiAgICAgIHAgPT4gdHJhbnNmb3JtZXJVdGlsLmNyZWF0ZU11bHRpTGluZUNvbW1lbnQoXG4gICAgICAgICAgcCwgYFNraXBwaW5nIHVuaGFuZGxlZCBtZW1iZXI6ICR7ZXNjYXBlRm9yQ29tbWVudChwLmdldFRleHQoKSl9YCkpKTtcblxuICBmb3IgKGNvbnN0IGZuRGVjbCBvZiBhYnN0cmFjdE1ldGhvZHMpIHtcbiAgICBjb25zdCBuYW1lID0gcHJvcGVydHlOYW1lKGZuRGVjbCk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBtdHQuZXJyb3IoZm5EZWNsLCAnYW5vbnltb3VzIGFic3RyYWN0IGZ1bmN0aW9uJyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qge3RhZ3MsIHBhcmFtZXRlck5hbWVzfSA9IG10dC5nZXRGdW5jdGlvblR5cGVKU0RvYyhbZm5EZWNsXSwgW10pO1xuICAgIGlmIChoYXNFeHBvcnRpbmdEZWNvcmF0b3IoZm5EZWNsLCBtdHQudHlwZUNoZWNrZXIpKSB0YWdzLnB1c2goe3RhZ05hbWU6ICdleHBvcnQnfSk7XG4gICAgLy8gbWVtYmVyTmFtZXNwYWNlIGJlY2F1c2UgYWJzdHJhY3QgbWV0aG9kcyBjYW5ub3QgYmUgc3RhdGljIGluIFR5cGVTY3JpcHQuXG4gICAgY29uc3QgYWJzdHJhY3RGbkRlY2wgPSB0cy5jcmVhdGVTdGF0ZW1lbnQodHMuY3JlYXRlQXNzaWdubWVudChcbiAgICAgICAgdHMuY3JlYXRlUHJvcGVydHlBY2Nlc3MoaW5zdGFuY2VQcm9wQWNjZXNzLCBuYW1lKSxcbiAgICAgICAgdHMuY3JlYXRlRnVuY3Rpb25FeHByZXNzaW9uKFxuICAgICAgICAgICAgLyogbW9kaWZpZXJzICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8qIGFzdGVyaXNrICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8qIG5hbWUgKi8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgLyogdHlwZVBhcmFtZXRlcnMgKi8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFyYW1ldGVyTmFtZXMubWFwKFxuICAgICAgICAgICAgICAgIG4gPT4gdHMuY3JlYXRlUGFyYW1ldGVyKFxuICAgICAgICAgICAgICAgICAgICAvKiBkZWNvcmF0b3JzICovIHVuZGVmaW5lZCwgLyogbW9kaWZpZXJzICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgLyogZG90RG90RG90ICovIHVuZGVmaW5lZCwgbikpLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHMuY3JlYXRlQmxvY2soW10pLFxuICAgICAgICAgICAgKSkpO1xuICAgIHRzLnNldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyhhYnN0cmFjdEZuRGVjbCwgW2pzZG9jLnRvU3ludGhlc2l6ZWRDb21tZW50KHRhZ3MpXSk7XG4gICAgcHJvcGVydHlEZWNscy5wdXNoKHRzLnNldFNvdXJjZU1hcFJhbmdlKGFic3RyYWN0Rm5EZWNsLCBmbkRlY2wpKTtcbiAgfVxuXG4gIC8vIFNlZSB0ZXN0X2ZpbGVzL2ZpZWxkcy9maWVsZHMudHM6QmFzZVRoYXRUaHJvd3MgZm9yIGEgbm90ZSBvbiB0aGlzIHdyYXBwZXIuXG4gIHJldHVybiB0cy5jcmVhdGVJZih0cy5jcmVhdGVMaXRlcmFsKGZhbHNlKSwgdHMuY3JlYXRlQmxvY2socHJvcGVydHlEZWNscywgdHJ1ZSkpO1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eU5hbWUocHJvcDogdHMuTmFtZWREZWNsYXJhdGlvbik6IHN0cmluZ3xudWxsIHtcbiAgaWYgKCFwcm9wLm5hbWUpIHJldHVybiBudWxsO1xuXG4gIHN3aXRjaCAocHJvcC5uYW1lLmtpbmQpIHtcbiAgICBjYXNlIHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcjpcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lclV0aWwuZ2V0SWRlbnRpZmllclRleHQocHJvcC5uYW1lIGFzIHRzLklkZW50aWZpZXIpO1xuICAgIGNhc2UgdHMuU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsOlxuICAgICAgLy8gRS5nLiBpbnRlcmZhY2UgRm9vIHsgJ2Jhcic6IG51bWJlcjsgfVxuICAgICAgLy8gSWYgJ2JhcicgaXMgYSBuYW1lIHRoYXQgaXMgbm90IHZhbGlkIGluIENsb3N1cmUgdGhlbiB0aGVyZSdzIG5vdGhpbmcgd2UgY2FuIGRvLlxuICAgICAgY29uc3QgdGV4dCA9IChwcm9wLm5hbWUgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dDtcbiAgICAgIGlmICghaXNWYWxpZENsb3N1cmVQcm9wZXJ0eU5hbWUodGV4dCkpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKiBSZW1vdmVzIGNvbW1lbnQgbWV0YWNoYXJhY3RlcnMgZnJvbSBhIHN0cmluZywgdG8gbWFrZSBpdCBzYWZlIHRvIGVtYmVkIGluIGEgY29tbWVudC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVGb3JDb21tZW50KHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXC9cXCovZywgJ19fJykucmVwbGFjZSgvXFwqXFwvL2csICdfXycpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbG9zdXJlUHJvcGVydHlEZWNsYXJhdGlvbihcbiAgICBtdHQ6IE1vZHVsZVR5cGVUcmFuc2xhdG9yLCBleHByOiB0cy5FeHByZXNzaW9uLFxuICAgIHByb3A6IHRzLlByb3BlcnR5RGVjbGFyYXRpb258dHMuUHJvcGVydHlTaWduYXR1cmV8dHMuUGFyYW1ldGVyRGVjbGFyYXRpb24sXG4gICAgb3B0aW9uYWw6IGJvb2xlYW4pOiB0cy5TdGF0ZW1lbnQge1xuICBjb25zdCBuYW1lID0gcHJvcGVydHlOYW1lKHByb3ApO1xuICBpZiAoIW5hbWUpIHtcbiAgICBtdHQuZGVidWdXYXJuKHByb3AsIGBoYW5kbGUgdW5uYW1lZCBtZW1iZXI6XFxuJHtlc2NhcGVGb3JDb21tZW50KHByb3AuZ2V0VGV4dCgpKX1gKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtZXJVdGlsLmNyZWF0ZU11bHRpTGluZUNvbW1lbnQoXG4gICAgICAgIHByb3AsIGBTa2lwcGluZyB1bm5hbWVkIG1lbWJlcjpcXG4ke2VzY2FwZUZvckNvbW1lbnQocHJvcC5nZXRUZXh0KCkpfWApO1xuICB9XG5cbiAgbGV0IHR5cGUgPSBtdHQudHlwZVRvQ2xvc3VyZShwcm9wKTtcbiAgLy8gV2hlbiBhIHByb3BlcnR5IGlzIG9wdGlvbmFsLCBlLmcuXG4gIC8vICAgZm9vPzogc3RyaW5nO1xuICAvLyBUaGVuIHRoZSBUeXBlU2NyaXB0IHR5cGUgb2YgdGhlIHByb3BlcnR5IGlzIHN0cmluZ3x1bmRlZmluZWQsIHRoZVxuICAvLyB0eXBlVG9DbG9zdXJlIHRyYW5zbGF0aW9uIGhhbmRsZXMgaXQgY29ycmVjdGx5LCBhbmQgc3RyaW5nfHVuZGVmaW5lZCBpc1xuICAvLyBob3cgeW91IHdyaXRlIGFuIG9wdGlvbmFsIHByb3BlcnR5IGluIENsb3N1cmUuXG4gIC8vXG4gIC8vIEJ1dCBpbiB0aGUgc3BlY2lhbCBjYXNlIG9mIGFuIG9wdGlvbmFsIHByb3BlcnR5IHdpdGggdHlwZSBhbnk6XG4gIC8vICAgZm9vPzogYW55O1xuICAvLyBUaGUgVHlwZVNjcmlwdCB0eXBlIG9mIHRoZSBwcm9wZXJ0eSBpcyBqdXN0IFwiYW55XCIgKGJlY2F1c2UgYW55IGluY2x1ZGVzXG4gIC8vIHVuZGVmaW5lZCBhcyB3ZWxsKSBzbyBvdXIgZGVmYXVsdCB0cmFuc2xhdGlvbiBvZiB0aGUgdHlwZSBpcyBqdXN0IFwiP1wiLlxuICAvLyBUbyBtYXJrIHRoZSBwcm9wZXJ0eSBhcyBvcHRpb25hbCBpbiBDbG9zdXJlIGl0IG11c3QgaGF2ZSBcInx1bmRlZmluZWRcIixcbiAgLy8gc28gdGhlIENsb3N1cmUgdHlwZSBtdXN0IGJlID98dW5kZWZpbmVkLlxuICBpZiAob3B0aW9uYWwgJiYgdHlwZSA9PT0gJz8nKSB0eXBlICs9ICd8dW5kZWZpbmVkJztcblxuICBjb25zdCB0YWdzID0gbXR0LmdldEpTRG9jKHByb3AsIC8qIHJlcG9ydFdhcm5pbmdzICovIHRydWUpO1xuICB0YWdzLnB1c2goe3RhZ05hbWU6ICd0eXBlJywgdHlwZX0pO1xuICBpZiAoaGFzRXhwb3J0aW5nRGVjb3JhdG9yKHByb3AsIG10dC50eXBlQ2hlY2tlcikpIHtcbiAgICB0YWdzLnB1c2goe3RhZ05hbWU6ICdleHBvcnQnfSk7XG4gIH1cbiAgY29uc3QgZGVjbFN0bXQgPVxuICAgICAgdHMuc2V0U291cmNlTWFwUmFuZ2UodHMuY3JlYXRlU3RhdGVtZW50KHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKGV4cHIsIG5hbWUpKSwgcHJvcCk7XG4gIC8vIEF2b2lkIHByaW50aW5nIGFubm90YXRpb25zIHRoYXQgY2FuIGNvbmZsaWN0IHdpdGggQHR5cGVcbiAgLy8gVGhpcyBhdm9pZHMgQ2xvc3VyZSdzIGVycm9yIFwidHlwZSBhbm5vdGF0aW9uIGluY29tcGF0aWJsZSB3aXRoIG90aGVyIGFubm90YXRpb25zXCJcbiAgYWRkQ29tbWVudE9uKGRlY2xTdG10LCB0YWdzLCBqc2RvYy5UQUdTX0NPTkZMSUNUSU5HX1dJVEhfVFlQRSk7XG4gIHJldHVybiBkZWNsU3RtdDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFueSB0eXBlIGFzc2VydGlvbnMgYW5kIG5vbi1udWxsIGV4cHJlc3Npb25zIGZyb20gdGhlIEFTVCBiZWZvcmUgVHlwZVNjcmlwdCBwcm9jZXNzaW5nLlxuICpcbiAqIElkZWFsbHksIHRoZSBjb2RlIGluIGpzZG9jX3RyYW5zZm9ybWVyIGJlbG93IHNob3VsZCBqdXN0IHJlbW92ZSB0aGUgY2FzdCBleHByZXNzaW9uIGFuZFxuICogcmVwbGFjZSBpdCB3aXRoIHRoZSBDbG9zdXJlIGVxdWl2YWxlbnQuIEhvd2V2ZXIgQW5ndWxhcidzIGNvbXBpbGVyIGlzIGZyYWdpbGUgdG8gQVNUXG4gKiBub2RlcyBiZWluZyByZW1vdmVkIG9yIGNoYW5naW5nIHR5cGUsIHNvIHRoZSBjb2RlIG11c3QgcmV0YWluIHRoZSB0eXBlIGFzc2VydGlvblxuICogZXhwcmVzc2lvbiwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yNDg5NS5cbiAqXG4gKiB0c2lja2xlIGFsc28gY2Fubm90IGp1c3QgZ2VuZXJhdGUgYW5kIGtlZXAgYSBgKC8uLiBAdHlwZSB7U29tZVR5cGV9IC4vIChleHByIGFzIFNvbWVUeXBlKSlgXG4gKiBiZWNhdXNlIFR5cGVTY3JpcHQgcmVtb3ZlcyB0aGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9ucyBpbiB0aGF0IHN5bnRheCwgKHJlYXNvbmFibHkpIGJlbGlldmluZ1xuICogdGhleSB3ZXJlIG9ubHkgYWRkZWQgZm9yIHRoZSBUUyBjYXN0LlxuICpcbiAqIFRoZSBmaW5hbCB3b3JrYXJvdW5kIGlzIHRoZW4gdG8ga2VlcCB0aGUgVHlwZVNjcmlwdCB0eXBlIGFzc2VydGlvbnMsIGFuZCBoYXZlIGEgcG9zdC1Bbmd1bGFyXG4gKiBwcm9jZXNzaW5nIHN0ZXAgdGhhdCByZW1vdmVzIHRoZSBhc3NlcnRpb25zIGJlZm9yZSBUeXBlU2NyaXB0IHNlZXMgdGhlbS5cbiAqXG4gKiBUT0RPKG1hcnRpbnByb2JzdCk6IHJlbW92ZSBvbmNlIHRoZSBBbmd1bGFyIGlzc3VlIGlzIGZpeGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVHlwZUFzc2VydGlvbnMoKTogdHMuVHJhbnNmb3JtZXJGYWN0b3J5PHRzLlNvdXJjZUZpbGU+IHtcbiAgcmV0dXJuIChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUpID0+IHtcbiAgICAgIGZ1bmN0aW9uIHZpc2l0b3Iobm9kZTogdHMuTm9kZSk6IHRzLk5vZGUge1xuICAgICAgICBzd2l0Y2ggKG5vZGUua2luZCkge1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5UeXBlQXNzZXJ0aW9uRXhwcmVzc2lvbjpcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQXNFeHByZXNzaW9uOlxuICAgICAgICAgICAgcmV0dXJuIHRzLnZpc2l0Tm9kZSgobm9kZSBhcyB0cy5Bc3NlcnRpb25FeHByZXNzaW9uKS5leHByZXNzaW9uLCB2aXNpdG9yKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuTm9uTnVsbEV4cHJlc3Npb246XG4gICAgICAgICAgICByZXR1cm4gdHMudmlzaXROb2RlKChub2RlIGFzIHRzLk5vbk51bGxFeHByZXNzaW9uKS5leHByZXNzaW9uLCB2aXNpdG9yKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRzLnZpc2l0RWFjaENoaWxkKG5vZGUsIHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmlzaXRvcihzb3VyY2VGaWxlKSBhcyB0cy5Tb3VyY2VGaWxlO1xuICAgIH07XG4gIH07XG59XG5cbi8qKlxuICoganNkb2NUcmFuc2Zvcm1lciByZXR1cm5zIGEgdHJhbnNmb3JtZXIgZmFjdG9yeSB0aGF0IGNvbnZlcnRzIFR5cGVTY3JpcHQgdHlwZXMgaW50byB0aGUgZXF1aXZhbGVudFxuICogSlNEb2MgYW5ub3RhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc2RvY1RyYW5zZm9ybWVyKFxuICAgIGhvc3Q6IEFubm90YXRvckhvc3QsIHRzT3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zLCB0c0hvc3Q6IHRzLkNvbXBpbGVySG9zdCxcbiAgICB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsIGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10pOlxuICAgIChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpID0+IHRzLlRyYW5zZm9ybWVyPHRzLlNvdXJjZUZpbGU+IHtcbiAgcmV0dXJuIChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpOiB0cy5UcmFuc2Zvcm1lcjx0cy5Tb3VyY2VGaWxlPiA9PiB7XG4gICAgcmV0dXJuIChzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlKSA9PiB7XG4gICAgICBjb25zdCBtb2R1bGVUeXBlVHJhbnNsYXRvciA9IG5ldyBNb2R1bGVUeXBlVHJhbnNsYXRvcihcbiAgICAgICAgICBzb3VyY2VGaWxlLCB0eXBlQ2hlY2tlciwgaG9zdCwgZGlhZ25vc3RpY3MsIC8qaXNGb3JFeHRlcm5zKi8gZmFsc2UpO1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgc2V0IG9mIGFsbCBuYW1lcyBleHBvcnRlZCBmcm9tIGFuIGV4cG9ydCAqIGluIHRoZSBjdXJyZW50IG1vZHVsZS4gVXNlZCB0byBwcmV2ZW50XG4gICAgICAgKiBlbWl0dGluZyBkdXBsaWNhdGVkIGV4cG9ydHMuIFRoZSBmaXJzdCBleHBvcnQgKiB0YWtlcyBwcmVjZWRlbmNlIGluIEVTNi5cbiAgICAgICAqL1xuICAgICAgY29uc3QgZXhwYW5kZWRTdGFySW1wb3J0cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgICAvKipcbiAgICAgICAqIFdoaWxlIENsb3N1cmUgY29tcGlsZXIgc3VwcG9ydHMgcGFyYW1ldGVyaXplZCB0eXBlcywgaW5jbHVkaW5nIHBhcmFtZXRlcml6ZWQgYHRoaXNgIG9uXG4gICAgICAgKiBtZXRob2RzLCBpdCBkb2VzIG5vdCBzdXBwb3J0IGNvbnN0cmFpbnRzIG9uIHRoZW0uIFRoYXQgbWVhbnMgdGhhdCBhbiBgXFxAdGVtcGxhdGVgZCB0eXBlIGlzXG4gICAgICAgKiBhbHdheXMgY29uc2lkZXJlZCB0byBiZSBgdW5rbm93bmAgd2l0aGluIHRoZSBtZXRob2QsIGluY2x1ZGluZyBgVEhJU2AuXG4gICAgICAgKlxuICAgICAgICogVG8gaGVscCBDbG9zdXJlIENvbXBpbGVyLCB3ZSBrZWVwIHRyYWNrIG9mIGFueSB0ZW1wbGF0ZWQgdGhpcyByZXR1cm4gdHlwZSwgYW5kIHN1YnN0aXR1dGVcbiAgICAgICAqIGV4cGxpY2l0IGNhc3RzIHRvIHRoZSB0ZW1wbGF0ZWQgdHlwZS5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIGFuIGluY29tcGxldGUgc29sdXRpb24gYW5kIHdvcmtzIGFyb3VuZCBhIHNwZWNpZmljIHByb2JsZW0gd2l0aCB3YXJuaW5ncyBvbiB1bmtub3duXG4gICAgICAgKiB0aGlzIGFjY2Vzc2VzLiBNb3JlIGdlbmVyYWxseSwgQ2xvc3VyZSBhbHNvIGNhbm5vdCBpbmZlciBjb25zdHJhaW50cyBmb3IgYW55IG90aGVyXG4gICAgICAgKiB0ZW1wbGF0ZWQgdHlwZXMsIGJ1dCB0aGF0IG1pZ2h0IHJlcXVpcmUgYSBtb3JlIGdlbmVyYWwgc29sdXRpb24gaW4gQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAqL1xuICAgICAgbGV0IGNvbnRleHRUaGlzVHlwZTogdHMuVHlwZXxudWxsID0gbnVsbDtcblxuICAgICAgZnVuY3Rpb24gdmlzaXRDbGFzc0RlY2xhcmF0aW9uKGNsYXNzRGVjbDogdHMuQ2xhc3NEZWNsYXJhdGlvbik6IHRzLlN0YXRlbWVudFtdIHtcbiAgICAgICAgY29uc3QgY29udGV4dFRoaXNUeXBlQmFja3VwID0gY29udGV4dFRoaXNUeXBlO1xuXG4gICAgICAgIGNvbnN0IG1qc2RvYyA9IG1vZHVsZVR5cGVUcmFuc2xhdG9yLmdldE11dGFibGVKU0RvYyhjbGFzc0RlY2wpO1xuICAgICAgICBpZiAodHJhbnNmb3JtZXJVdGlsLmhhc01vZGlmaWVyRmxhZyhjbGFzc0RlY2wsIHRzLk1vZGlmaWVyRmxhZ3MuQWJzdHJhY3QpKSB7XG4gICAgICAgICAgbWpzZG9jLnRhZ3MucHVzaCh7dGFnTmFtZTogJ2Fic3RyYWN0J30pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF5YmVBZGRUZW1wbGF0ZUNsYXVzZShtanNkb2MudGFncywgY2xhc3NEZWNsKTtcbiAgICAgICAgaWYgKCFob3N0LnVudHlwZWQpIHtcbiAgICAgICAgICBtYXliZUFkZEhlcml0YWdlQ2xhdXNlcyhtanNkb2MudGFncywgbW9kdWxlVHlwZVRyYW5zbGF0b3IsIGNsYXNzRGVjbCk7XG4gICAgICAgIH1cbiAgICAgICAgbWpzZG9jLnVwZGF0ZUNvbW1lbnQoKTtcbiAgICAgICAgY29uc3QgZGVjbHM6IHRzLlN0YXRlbWVudFtdID0gW107XG4gICAgICAgIGNvbnN0IG1lbWJlckRlY2wgPSBjcmVhdGVNZW1iZXJUeXBlRGVjbGFyYXRpb24obW9kdWxlVHlwZVRyYW5zbGF0b3IsIGNsYXNzRGVjbCk7XG4gICAgICAgIC8vIFdBUk5JTkc6IG9yZGVyIGlzIHNpZ25pZmljYW50OyB3ZSBtdXN0IGNyZWF0ZSB0aGUgbWVtYmVyIGRlY2wgYmVmb3JlIHRyYW5zZm9ybWluZyBhd2F5XG4gICAgICAgIC8vIHBhcmFtZXRlciBwcm9wZXJ0eSBjb21tZW50cyB3aGVuIHZpc2l0aW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgZGVjbHMucHVzaCh0cy52aXNpdEVhY2hDaGlsZChjbGFzc0RlY2wsIHZpc2l0b3IsIGNvbnRleHQpKTtcbiAgICAgICAgaWYgKG1lbWJlckRlY2wpIGRlY2xzLnB1c2gobWVtYmVyRGVjbCk7XG4gICAgICAgIGNvbnRleHRUaGlzVHlwZSA9IGNvbnRleHRUaGlzVHlwZUJhY2t1cDtcbiAgICAgICAgcmV0dXJuIGRlY2xzO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHZpc2l0SGVyaXRhZ2VDbGF1c2Ugd29ya3MgYXJvdW5kIGEgQ2xvc3VyZSBDb21waWxlciBpc3N1ZSwgd2hlcmUgdGhlIGV4cHJlc3Npb24gaW4gYW5cbiAgICAgICAqIFwiZXh0ZW5kc1wiIGNsYXVzZSBtdXN0IGJlIGEgc2ltcGxlIGlkZW50aWZpZXIsIGFuZCBpbiBwYXJ0aWN1bGFyIG11c3Qgbm90IGJlIGEgcGFyZW50aGVzaXplZFxuICAgICAgICogZXhwcmVzc2lvbi5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGlzIHRyaWdnZXJlZCB3aGVuIFRTIGNvZGUgd3JpdGVzIFwiY2xhc3MgWCBleHRlbmRzIChGb28gYXMgQmFyKSB7IC4uLiB9XCIsIGNvbW1vbmx5IGRvbmVcbiAgICAgICAqIHRvIHN1cHBvcnQgbWl4aW5zLiBGb3IgZXh0ZW5kcyBjbGF1c2VzIGluIGNsYXNzZXMsIHRoZSBjb2RlIGJlbG93IGRyb3BzIHRoZSBjYXN0IGFuZCBhbnlcbiAgICAgICAqIHBhcmVudGhldGljYWxzLCBsZWF2aW5nIGp1c3QgdGhlIG9yaWdpbmFsIGV4cHJlc3Npb24uXG4gICAgICAgKlxuICAgICAgICogVGhpcyBpcyBhbiBpbmNvbXBsZXRlIHdvcmthcm91bmQsIGFzIENsb3N1cmUgd2lsbCBzdGlsbCBiYWlsIG9uIG90aGVyIHN1cGVyIGV4cHJlc3Npb25zLFxuICAgICAgICogYnV0IHJldGFpbnMgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBwcmV2aW91cyBlbWl0IHRoYXQgKGFjY2lkZW50YWxseSkgZHJvcHBlZCB0aGUgY2FzdFxuICAgICAgICogZXhwcmVzc2lvbi5cbiAgICAgICAqXG4gICAgICAgKiBUT0RPKG1hcnRpbnByb2JzdCk6IHJlbW92ZSB0aGlzIG9uY2UgdGhlIENsb3N1cmUgc2lkZSBpc3N1ZSBoYXMgYmVlbiByZXNvbHZlZC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gdmlzaXRIZXJpdGFnZUNsYXVzZShoZXJpdGFnZUNsYXVzZTogdHMuSGVyaXRhZ2VDbGF1c2UpIHtcbiAgICAgICAgaWYgKGhlcml0YWdlQ2xhdXNlLnRva2VuICE9PSB0cy5TeW50YXhLaW5kLkV4dGVuZHNLZXl3b3JkIHx8ICFoZXJpdGFnZUNsYXVzZS5wYXJlbnQgfHxcbiAgICAgICAgICAgIGhlcml0YWdlQ2xhdXNlLnBhcmVudC5raW5kID09PSB0cy5TeW50YXhLaW5kLkludGVyZmFjZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRzLnZpc2l0RWFjaENoaWxkKGhlcml0YWdlQ2xhdXNlLCB2aXNpdG9yLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyaXRhZ2VDbGF1c2UudHlwZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IuZXJyb3IoXG4gICAgICAgICAgICAgIGhlcml0YWdlQ2xhdXNlLCBgZXhwZWN0ZWQgZXhhY3RseSBvbmUgdHlwZSBpbiBjbGFzcyBleHRlbnNpb24gY2xhdXNlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IGhlcml0YWdlQ2xhdXNlLnR5cGVzWzBdO1xuICAgICAgICBsZXQgZXhwcjogdHMuRXhwcmVzc2lvbiA9IHR5cGUuZXhwcmVzc2lvbjtcbiAgICAgICAgd2hpbGUgKHRzLmlzUGFyZW50aGVzaXplZEV4cHJlc3Npb24oZXhwcikgfHwgdHMuaXNOb25OdWxsRXhwcmVzc2lvbihleHByKSB8fFxuICAgICAgICAgICAgICAgdHMuaXNBc3NlcnRpb25FeHByZXNzaW9uKGV4cHIpKSB7XG4gICAgICAgICAgZXhwciA9IGV4cHIuZXhwcmVzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHMudXBkYXRlSGVyaXRhZ2VDbGF1c2UoaGVyaXRhZ2VDbGF1c2UsIFt0cy51cGRhdGVFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsIHR5cGUudHlwZUFyZ3VtZW50cyB8fCBbXSwgZXhwcildKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmlzaXRJbnRlcmZhY2VEZWNsYXJhdGlvbihpZmFjZTogdHMuSW50ZXJmYWNlRGVjbGFyYXRpb24pOiB0cy5TdGF0ZW1lbnRbXSB7XG4gICAgICAgIGNvbnN0IHN5bSA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oaWZhY2UubmFtZSk7XG4gICAgICAgIGlmICghc3ltKSB7XG4gICAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IuZXJyb3IoaWZhY2UsICdpbnRlcmZhY2Ugd2l0aCBubyBzeW1ib2wnKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhpcyBzeW1ib2wgaXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUsIHdlIGNhbm5vdCBlbWl0IGJvdGggaW50byBDbG9zdXJlJ3NcbiAgICAgICAgLy8gc2luZ2xlIG5hbWVzcGFjZS5cbiAgICAgICAgaWYgKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlKSB7XG4gICAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IuZGVidWdXYXJuKFxuICAgICAgICAgICAgICBpZmFjZSwgYHR5cGUvc3ltYm9sIGNvbmZsaWN0IGZvciAke3N5bS5uYW1lfSwgdXNpbmcgez99IGZvciBub3dgKTtcbiAgICAgICAgICByZXR1cm4gW3RyYW5zZm9ybWVyVXRpbC5jcmVhdGVTaW5nbGVMaW5lQ29tbWVudChcbiAgICAgICAgICAgICAgaWZhY2UsICdXQVJOSU5HOiBpbnRlcmZhY2UgaGFzIGJvdGggYSB0eXBlIGFuZCBhIHZhbHVlLCBza2lwcGluZyBlbWl0JyldO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFncyA9IG1vZHVsZVR5cGVUcmFuc2xhdG9yLmdldEpTRG9jKGlmYWNlLCAvKiByZXBvcnRXYXJuaW5ncyAqLyB0cnVlKSB8fCBbXTtcbiAgICAgICAgdGFncy5wdXNoKHt0YWdOYW1lOiAncmVjb3JkJ30pO1xuICAgICAgICBtYXliZUFkZFRlbXBsYXRlQ2xhdXNlKHRhZ3MsIGlmYWNlKTtcbiAgICAgICAgaWYgKCFob3N0LnVudHlwZWQpIHtcbiAgICAgICAgICBtYXliZUFkZEhlcml0YWdlQ2xhdXNlcyh0YWdzLCBtb2R1bGVUeXBlVHJhbnNsYXRvciwgaWZhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0cmFuc2Zvcm1lclV0aWwuZ2V0SWRlbnRpZmllclRleHQoaWZhY2UubmFtZSk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IHRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcoaWZhY2UsIHRzLk1vZGlmaWVyRmxhZ3MuRXhwb3J0KSA/XG4gICAgICAgICAgICBbdHMuY3JlYXRlVG9rZW4odHMuU3ludGF4S2luZC5FeHBvcnRLZXl3b3JkKV0gOlxuICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBkZWNsID0gdHMuc2V0U291cmNlTWFwUmFuZ2UoXG4gICAgICAgICAgICB0cy5jcmVhdGVGdW5jdGlvbkRlY2xhcmF0aW9uKFxuICAgICAgICAgICAgICAgIC8qIGRlY29yYXRvcnMgKi8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgICAgICAgICAvKiBhc3RlcmlzayAqLyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAvKiB0eXBlUGFyYW1ldGVycyAqLyB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLyogcGFyYW1ldGVycyAqL1tdLFxuICAgICAgICAgICAgICAgIC8qIHR5cGUgKi8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC8qIGJvZHkgKi8gdHMuY3JlYXRlQmxvY2soW10pLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICBpZmFjZSk7XG4gICAgICAgIGFkZENvbW1lbnRPbihkZWNsLCB0YWdzKTtcbiAgICAgICAgY29uc3QgbWVtYmVyRGVjbCA9IGNyZWF0ZU1lbWJlclR5cGVEZWNsYXJhdGlvbihtb2R1bGVUeXBlVHJhbnNsYXRvciwgaWZhY2UpO1xuICAgICAgICByZXR1cm4gbWVtYmVyRGVjbCA/IFtkZWNsLCBtZW1iZXJEZWNsXSA6IFtkZWNsXTtcbiAgICAgIH1cblxuICAgICAgLyoqIEZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBhcmUgZW1pdHRlZCBhcyB0aGV5IGFyZSwgd2l0aCBvbmx5IEpTRG9jIGFkZGVkLiAqL1xuICAgICAgZnVuY3Rpb24gdmlzaXRGdW5jdGlvbkxpa2VEZWNsYXJhdGlvbihmbkRlY2w6IHRzLkZ1bmN0aW9uTGlrZURlY2xhcmF0aW9uKSB7XG4gICAgICAgIGlmICghZm5EZWNsLmJvZHkpIHtcbiAgICAgICAgICAvLyBUd28gY2FzZXM6IGFic3RyYWN0IG1ldGhvZHMgYW5kIG92ZXJsb2FkZWQgbWV0aG9kcy9mdW5jdGlvbnMuXG4gICAgICAgICAgLy8gQWJzdHJhY3QgbWV0aG9kcyBhcmUgaGFuZGxlZCBpbiBlbWl0VHlwZUFubm90YXRpb25zSGFuZGxlci5cbiAgICAgICAgICAvLyBPdmVybG9hZHMgYXJlIHVuaW9uLWl6ZWQgaW50byB0aGUgc2hhcmVkIHR5cGUgaW4gRnVuY3Rpb25UeXBlLlxuICAgICAgICAgIHJldHVybiB0cy52aXNpdEVhY2hDaGlsZChmbkRlY2wsIHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4dHJhVGFncyA9IFtdO1xuICAgICAgICBpZiAoaGFzRXhwb3J0aW5nRGVjb3JhdG9yKGZuRGVjbCwgdHlwZUNoZWNrZXIpKSBleHRyYVRhZ3MucHVzaCh7dGFnTmFtZTogJ2V4cG9ydCd9KTtcblxuICAgICAgICBjb25zdCB7dGFncywgdGhpc1JldHVyblR5cGV9ID1cbiAgICAgICAgICAgIG1vZHVsZVR5cGVUcmFuc2xhdG9yLmdldEZ1bmN0aW9uVHlwZUpTRG9jKFtmbkRlY2xdLCBleHRyYVRhZ3MpO1xuICAgICAgICBjb25zdCBtanNkb2MgPSBtb2R1bGVUeXBlVHJhbnNsYXRvci5nZXRNdXRhYmxlSlNEb2MoZm5EZWNsKTtcbiAgICAgICAgbWpzZG9jLnRhZ3MgPSB0YWdzO1xuICAgICAgICBtanNkb2MudXBkYXRlQ29tbWVudCgpO1xuICAgICAgICBtb2R1bGVUeXBlVHJhbnNsYXRvci5ibGFja2xpc3RUeXBlUGFyYW1ldGVycyhmbkRlY2wsIGZuRGVjbC50eXBlUGFyYW1ldGVycyk7XG5cbiAgICAgICAgY29uc3QgY29udGV4dFRoaXNUeXBlQmFja3VwID0gY29udGV4dFRoaXNUeXBlO1xuICAgICAgICBjb250ZXh0VGhpc1R5cGUgPSB0aGlzUmV0dXJuVHlwZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdHMudmlzaXRFYWNoQ2hpbGQoZm5EZWNsLCB2aXNpdG9yLCBjb250ZXh0KTtcbiAgICAgICAgY29udGV4dFRoaXNUeXBlID0gY29udGV4dFRoaXNUeXBlQmFja3VwO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEluIG1ldGhvZHMgd2l0aCBhIHRlbXBsYXRlZCB0aGlzIHR5cGUsIGFkZHMgZXhwbGljaXQgY2FzdHMgdG8gYWNjZXNzZXMgb24gdGhpcy5cbiAgICAgICAqXG4gICAgICAgKiBAc2VlIGNvbnRleHRUaGlzVHlwZVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiB2aXNpdFRoaXNFeHByZXNzaW9uKG5vZGU6IHRzLlRoaXNFeHByZXNzaW9uKSB7XG4gICAgICAgIGlmICghY29udGV4dFRoaXNUeXBlKSByZXR1cm4gdHMudmlzaXRFYWNoQ2hpbGQobm9kZSwgdmlzaXRvciwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBjcmVhdGVDbG9zdXJlQ2FzdChub2RlLCBub2RlLCBjb250ZXh0VGhpc1R5cGUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHZpc2l0VmFyaWFibGVTdGF0ZW1lbnQgZmxhdHRlbnMgdmFyaWFibGUgZGVjbGFyYXRpb24gbGlzdHMgKGB2YXIgYSwgYjtgIHRvIGB2YXIgYTsgdmFyXG4gICAgICAgKiBiO2ApLCBhbmQgYXR0YWNoZXMgSlNEb2MgY29tbWVudHMgdG8gZWFjaCB2YXJpYWJsZS4gSlNEb2MgY29tbWVudHMgcHJlY2VkaW5nIHRoZVxuICAgICAgICogb3JpZ2luYWwgdmFyaWFibGUgYXJlIGF0dGFjaGVkIHRvIHRoZSBmaXJzdCBuZXdseSBjcmVhdGVkIG9uZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gdmlzaXRWYXJpYWJsZVN0YXRlbWVudCh2YXJTdG10OiB0cy5WYXJpYWJsZVN0YXRlbWVudCk6IHRzLlN0YXRlbWVudFtdIHtcbiAgICAgICAgY29uc3Qgc3RtdHM6IHRzLlN0YXRlbWVudFtdID0gW107XG5cbiAgICAgICAgLy8gXCJjb25zdFwiLCBcImxldFwiLCBldGMgYXJlIHN0b3JlZCBpbiBub2RlIGZsYWdzIG9uIHRoZSBkZWNsYXJhdGlvbkxpc3QuXG4gICAgICAgIGNvbnN0IGZsYWdzID0gdHMuZ2V0Q29tYmluZWROb2RlRmxhZ3ModmFyU3RtdC5kZWNsYXJhdGlvbkxpc3QpO1xuXG4gICAgICAgIGxldCB0YWdzOiBqc2RvYy5UYWdbXXxudWxsID1cbiAgICAgICAgICAgIG1vZHVsZVR5cGVUcmFuc2xhdG9yLmdldEpTRG9jKHZhclN0bXQsIC8qIHJlcG9ydFdhcm5pbmdzICovIHRydWUpO1xuICAgICAgICBjb25zdCBsZWFkaW5nID0gdHMuZ2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKHZhclN0bXQpO1xuICAgICAgICBpZiAobGVhZGluZykge1xuICAgICAgICAgIC8vIEF0dGFjaCBub24tSlNEb2MgY29tbWVudHMgdG8gYSBub3QgZW1pdHRlZCBzdGF0ZW1lbnQuXG4gICAgICAgICAgY29uc3QgY29tbWVudEhvbGRlciA9IHRzLmNyZWF0ZU5vdEVtaXR0ZWRTdGF0ZW1lbnQodmFyU3RtdCk7XG4gICAgICAgICAgdHMuc2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKGNvbW1lbnRIb2xkZXIsIGxlYWRpbmcuZmlsdGVyKGMgPT4gYy50ZXh0WzBdICE9PSAnKicpKTtcbiAgICAgICAgICBzdG10cy5wdXNoKGNvbW1lbnRIb2xkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVjbExpc3QgPSB0cy52aXNpdE5vZGUodmFyU3RtdC5kZWNsYXJhdGlvbkxpc3QsIHZpc2l0b3IpO1xuICAgICAgICBmb3IgKGNvbnN0IGRlY2wgb2YgZGVjbExpc3QuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWxUYWdzOiBqc2RvYy5UYWdbXSA9IFtdO1xuICAgICAgICAgIGlmICh0YWdzKSB7XG4gICAgICAgICAgICAvLyBBZGQgYW55IHRhZ3MgYW5kIGRvY3MgcHJlY2VkaW5nIHRoZSBlbnRpcmUgc3RhdGVtZW50IHRvIHRoZSBmaXJzdCB2YXJpYWJsZS5cbiAgICAgICAgICAgIGxvY2FsVGFncy5wdXNoKC4uLnRhZ3MpO1xuICAgICAgICAgICAgdGFncyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFkZCBhbiBAdHlwZSBmb3IgcGxhaW4gaWRlbnRpZmllcnMsIGJ1dCBub3QgZm9yIGJpbmRpbmdzIHBhdHRlcm5zIChpLmUuIG9iamVjdCBvciBhcnJheVxuICAgICAgICAgIC8vIGRlc3RydWN0dXJpbmcpIC0gdGhvc2UgZG8gbm90IGhhdmUgYSBzeW50YXggaW4gQ2xvc3VyZS5cbiAgICAgICAgICBpZiAodHMuaXNJZGVudGlmaWVyKGRlY2wubmFtZSkpIHtcbiAgICAgICAgICAgIC8vIEZvciB2YXJpYWJsZXMgdGhhdCBhcmUgaW5pdGlhbGl6ZWQgYW5kIHVzZSBhIGJsYWNrbGlzdGVkIHR5cGUsIGRvIG5vdCBlbWl0IGEgdHlwZSBhdFxuICAgICAgICAgICAgLy8gYWxsLiBDbG9zdXJlIENvbXBpbGVyIG1pZ2h0IGJlIGFibGUgdG8gaW5mZXIgYSBiZXR0ZXIgdHlwZSBmcm9tIHRoZSBpbml0aWFsaXplciB0aGFuXG4gICAgICAgICAgICAvLyB0aGUgYD9gIHRoZSBjb2RlIGJlbG93IHdvdWxkIGVtaXQuXG4gICAgICAgICAgICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IGNvbnNpZGVyIGRvaW5nIHRoaXMgZm9yIGFsbCB0eXBlcyB0aGF0IGdldCBlbWl0dGVkIGFzID8sIG5vdCBqdXN0XG4gICAgICAgICAgICAvLyBmb3IgYmxhY2tsaXN0ZWQgb25lcy5cbiAgICAgICAgICAgIGNvbnN0IGJsYWNrTGlzdGVkSW5pdGlhbGl6ZWQgPVxuICAgICAgICAgICAgICAgICEhZGVjbC5pbml0aWFsaXplciAmJiBtb2R1bGVUeXBlVHJhbnNsYXRvci5pc0JsYWNrTGlzdGVkKGRlY2wpO1xuICAgICAgICAgICAgaWYgKCFibGFja0xpc3RlZEluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgIC8vIGdldE9yaWdpbmFsTm9kZShkZWNsKSBpcyByZXF1aXJlZCBiZWNhdXNlIHRoZSB0eXBlIGNoZWNrZXIgY2Fubm90IHR5cGUgY2hlY2tcbiAgICAgICAgICAgICAgLy8gc3ludGhlc2l6ZWQgbm9kZXMuXG4gICAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPSBtb2R1bGVUeXBlVHJhbnNsYXRvci50eXBlVG9DbG9zdXJlKHRzLmdldE9yaWdpbmFsTm9kZShkZWNsKSk7XG4gICAgICAgICAgICAgIGxvY2FsVGFncy5wdXNoKHt0YWdOYW1lOiAndHlwZScsIHR5cGU6IHR5cGVTdHJ9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbmV3U3RtdCA9IHRzLmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KFxuICAgICAgICAgICAgICB2YXJTdG10Lm1vZGlmaWVycywgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoW2RlY2xdLCBmbGFncykpO1xuICAgICAgICAgIGlmIChsb2NhbFRhZ3MubGVuZ3RoKSBhZGRDb21tZW50T24obmV3U3RtdCwgbG9jYWxUYWdzLCBqc2RvYy5UQUdTX0NPTkZMSUNUSU5HX1dJVEhfVFlQRSk7XG4gICAgICAgICAgc3RtdHMucHVzaChuZXdTdG10KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdG10cztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBzaG91bGRFbWl0RXhwb3J0c0Fzc2lnbm1lbnRzIHJldHVybnMgdHJ1ZSBpZiB0c2lja2xlIHNob3VsZCBlbWl0IGBleHBvcnRzLkZvbyA9IC4uLmAgc3R5bGVcbiAgICAgICAqIGV4cG9ydCBzdGF0ZW1lbnRzLlxuICAgICAgICpcbiAgICAgICAqIFR5cGVTY3JpcHQgbW9kdWxlcyBjYW4gZXhwb3J0IHR5cGVzLiBCZWNhdXNlIHR5cGVzIGFyZSBwdXJlIGRlc2lnbi10aW1lIGNvbnN0cnVjdHMgaW5cbiAgICAgICAqIFR5cGVTY3JpcHQsIGl0IGRvZXMgbm90IGVtaXQgYW55IGFjdHVhbCBleHBvcnRlZCBzeW1ib2xzIGZvciB0aGVzZS4gQnV0IHRzaWNrbGUgaGFzIHRvIGVtaXRcbiAgICAgICAqIGFuIGV4cG9ydCwgc28gdGhhdCBkb3duc3RyZWFtIENsb3N1cmUgY29kZSAoaW5jbHVkaW5nIHRzaWNrbGUtY29udmVydGVkIENsb3N1cmUgY29kZSkgY2FuXG4gICAgICAgKiBpbXBvcnQgdXBzdHJlYW0gdHlwZXMuIHRzaWNrbGUgaGFzIHRvIHBpY2sgYSBtb2R1bGUgZm9ybWF0IGZvciB0aGF0LCBiZWNhdXNlIHRoZSBwdXJlIEVTNlxuICAgICAgICogZXhwb3J0IHdvdWxkIGdldCBzdHJpcHBlZCBieSBUeXBlU2NyaXB0LlxuICAgICAgICpcbiAgICAgICAqIHRzaWNrbGUgdXNlcyBDb21tb25KUyB0byBlbWl0IGdvb2dtb2R1bGUsIGFuZCBjb2RlIG5vdCB1c2luZyBnb29nbW9kdWxlIGRvZXNuJ3QgY2FyZSBhYm91dFxuICAgICAgICogdGhlIENsb3N1cmUgYW5ub3RhdGlvbnMgYW55d2F5LCBzbyB0c2lja2xlIHNraXBzIGVtaXR0aW5nIGV4cG9ydHMgaWYgdGhlIG1vZHVsZSB0YXJnZXRcbiAgICAgICAqIGlzbid0IGNvbW1vbmpzLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBzaG91bGRFbWl0RXhwb3J0c0Fzc2lnbm1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdHNPcHRpb25zLm1vZHVsZSA9PT0gdHMuTW9kdWxlS2luZC5Db21tb25KUztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmlzaXRUeXBlQWxpYXNEZWNsYXJhdGlvbih0eXBlQWxpYXM6IHRzLlR5cGVBbGlhc0RlY2xhcmF0aW9uKTogdHMuU3RhdGVtZW50W10ge1xuICAgICAgICAvLyBJZiB0aGUgdHlwZSBpcyBhbHNvIGRlZmluZWQgYXMgYSB2YWx1ZSwgc2tpcCBlbWl0dGluZyBpdC4gQ2xvc3VyZSBjb2xsYXBzZXMgdHlwZSAmIHZhbHVlXG4gICAgICAgIC8vIG5hbWVzcGFjZXMsIHRoZSB0d28gZW1pdHMgd291bGQgY29uZmxpY3QgaWYgdHNpY2tsZSBlbWl0dGVkIGJvdGguXG4gICAgICAgIGNvbnN0IHN5bSA9IG1vZHVsZVR5cGVUcmFuc2xhdG9yLm11c3RHZXRTeW1ib2xBdExvY2F0aW9uKHR5cGVBbGlhcy5uYW1lKTtcbiAgICAgICAgaWYgKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlKSByZXR1cm4gW107XG4gICAgICAgIC8vIFR5cGUgYWxpYXNlcyBhcmUgYWx3YXlzIGVtaXR0ZWQgYXMgdGhlIHJlc29sdmVkIHVuZGVybHlpbmcgdHlwZSwgc28gdGhlcmUgaXMgbm8gbmVlZCB0b1xuICAgICAgICAvLyBlbWl0IGFueXRoaW5nLCBleGNlcHQgZm9yIGV4cG9ydGVkIHR5cGVzLlxuICAgICAgICBpZiAoIXRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcodHlwZUFsaWFzLCB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCkpIHJldHVybiBbXTtcbiAgICAgICAgaWYgKCFzaG91bGRFbWl0RXhwb3J0c0Fzc2lnbm1lbnRzKCkpIHJldHVybiBbXTtcblxuICAgICAgICBjb25zdCB0eXBlTmFtZSA9IHR5cGVBbGlhcy5uYW1lLmdldFRleHQoKTtcblxuICAgICAgICAvLyBCbGFja2xpc3QgYW55IHR5cGUgcGFyYW1ldGVycywgQ2xvc3VyZSBkb2VzIG5vdCBzdXBwb3J0IHR5cGUgYWxpYXNlcyB3aXRoIHR5cGVcbiAgICAgICAgLy8gcGFyYW1ldGVycy5cbiAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IubmV3VHlwZVRyYW5zbGF0b3IodHlwZUFsaWFzKS5ibGFja2xpc3RUeXBlUGFyYW1ldGVycyhcbiAgICAgICAgICAgIG1vZHVsZVR5cGVUcmFuc2xhdG9yLnN5bWJvbHNUb0FsaWFzZWROYW1lcywgdHlwZUFsaWFzLnR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgdHlwZVN0ciA9XG4gICAgICAgICAgICBob3N0LnVudHlwZWQgPyAnPycgOiBtb2R1bGVUeXBlVHJhbnNsYXRvci50eXBlVG9DbG9zdXJlKHR5cGVBbGlhcywgdW5kZWZpbmVkKTtcbiAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW4gZXhwb3J0LCB3ZSBjYW5ub3QgZW1pdCBhIGBleHBvcnQgdmFyIGZvbztgIGJlY2F1c2UgVHlwZVNjcmlwdCBkcm9wc1xuICAgICAgICAvLyBleHBvcnRzIHRoYXQgYXJlIG5ldmVyIGFzc2lnbmVkIHZhbHVlcywgYW5kIENsb3N1cmUgcmVxdWlyZXMgdXMgdG8gbm90IGFzc2lnbiB2YWx1ZXMgdG9cbiAgICAgICAgLy8gdHlwZWRlZiBleHBvcnRzLiBJbnRyb2R1Y2luZyBhIG5ldyBsb2NhbCB2YXJpYWJsZSBhbmQgZXhwb3J0aW5nIGl0IGNhbiBjYXVzZSBidWdzIGR1ZSB0b1xuICAgICAgICAvLyBuYW1lIHNoYWRvd2luZyBhbmQgY29uZnVzaW5nIFR5cGVTY3JpcHQncyBsb2dpYyBvbiB3aGF0IHN5bWJvbHMgYW5kIHR5cGVzIHZzIHZhbHVlcyBhcmVcbiAgICAgICAgLy8gZXhwb3J0ZWQuIE1hbmdsaW5nIHRoZSBuYW1lIHRvIGF2b2lkIHRoZSBjb25mbGljdHMgd291bGQgYmUgcmVhc29uYWJseSBjbGVhbiwgYnV0IHdvdWxkXG4gICAgICAgIC8vIHJlcXVpcmUgYSB0d28gcGFzcyBlbWl0IHRvIGZpcnN0IGZpbmQgYWxsIHR5cGUgYWxpYXMgbmFtZXMsIG1hbmdsZSB0aGVtLCBhbmQgZW1pdCB0aGUgdXNlXG4gICAgICAgIC8vIHNpdGVzIG9ubHkgbGF0ZXIuIFdpdGggdGhhdCwgdGhlIGZpeCBoZXJlIGlzIHRvIG5ldmVyIGVtaXQgdHlwZSBhbGlhc2VzLCBidXQgYWx3YXlzXG4gICAgICAgIC8vIHJlc29sdmUgdGhlIGFsaWFzIGFuZCBlbWl0IHRoZSB1bmRlcmx5aW5nIHR5cGUgKGZpeGluZyByZWZlcmVuY2VzIGluIHRoZSBsb2NhbCBtb2R1bGUsXG4gICAgICAgIC8vIGFuZCBhbHNvIGFjcm9zcyBtb2R1bGVzKS4gRm9yIGRvd25zdHJlYW0gSmF2YVNjcmlwdCBjb2RlIHRoYXQgaW1wb3J0cyB0aGUgdHlwZWRlZiwgd2VcbiAgICAgICAgLy8gZW1pdCBhbiBcImV4cG9ydC5Gb287XCIgdGhhdCBkZWNsYXJlcyBhbmQgZXhwb3J0cyB0aGUgdHlwZSwgYW5kIGZvciBUeXBlU2NyaXB0IGhhcyBub1xuICAgICAgICAvLyBpbXBhY3QuXG4gICAgICAgIGNvbnN0IHRhZ3MgPSBtb2R1bGVUeXBlVHJhbnNsYXRvci5nZXRKU0RvYyh0eXBlQWxpYXMsIC8qIHJlcG9ydFdhcm5pbmdzICovIHRydWUpO1xuICAgICAgICB0YWdzLnB1c2goe3RhZ05hbWU6ICd0eXBlZGVmJywgdHlwZTogdHlwZVN0cn0pO1xuICAgICAgICBjb25zdCBkZWNsID0gdHMuc2V0U291cmNlTWFwUmFuZ2UoXG4gICAgICAgICAgICB0cy5jcmVhdGVTdGF0ZW1lbnQodHMuY3JlYXRlUHJvcGVydHlBY2Nlc3MoXG4gICAgICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcignZXhwb3J0cycpLCB0cy5jcmVhdGVJZGVudGlmaWVyKHR5cGVOYW1lKSkpLFxuICAgICAgICAgICAgdHlwZUFsaWFzKTtcbiAgICAgICAgYWRkQ29tbWVudE9uKGRlY2wsIHRhZ3MsIGpzZG9jLlRBR1NfQ09ORkxJQ1RJTkdfV0lUSF9UWVBFKTtcbiAgICAgICAgcmV0dXJuIFtkZWNsXTtcbiAgICAgIH1cblxuICAgICAgLyoqIEVtaXRzIGEgcGFyZW50aGVzaXplZCBDbG9zdXJlIGNhc3Q6IGAoLyoqIFxcQHR5cGUgLi4uICogLyAoZXhwcikpYC4gKi9cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNsb3N1cmVDYXN0KGNvbnRleHQ6IHRzLk5vZGUsIGV4cHJlc3Npb246IHRzLkV4cHJlc3Npb24sIHR5cGU6IHRzLlR5cGUpIHtcbiAgICAgICAgY29uc3QgaW5uZXIgPSB0cy5jcmVhdGVQYXJlbihleHByZXNzaW9uKTtcbiAgICAgICAgY29uc3QgY29tbWVudCA9IGFkZENvbW1lbnRPbihcbiAgICAgICAgICAgIGlubmVyLCBbe3RhZ05hbWU6ICd0eXBlJywgdHlwZTogbW9kdWxlVHlwZVRyYW5zbGF0b3IudHlwZVRvQ2xvc3VyZShjb250ZXh0LCB0eXBlKX1dKTtcbiAgICAgICAgY29tbWVudC5oYXNUcmFpbGluZ05ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRzLnNldFNvdXJjZU1hcFJhbmdlKHRzLmNyZWF0ZVBhcmVuKGlubmVyKSwgY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIC8qKiBDb252ZXJ0cyBhIFR5cGVTY3JpcHQgdHlwZSBhc3NlcnRpb24gaW50byBhIENsb3N1cmUgQ2FzdC4gKi9cbiAgICAgIGZ1bmN0aW9uIHZpc2l0QXNzZXJ0aW9uRXhwcmVzc2lvbihhc3NlcnRpb246IHRzLkFzc2VydGlvbkV4cHJlc3Npb24pIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKGFzc2VydGlvbi50eXBlKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNsb3N1cmVDYXN0KGFzc2VydGlvbiwgdHMudmlzaXRFYWNoQ2hpbGQoYXNzZXJ0aW9uLCB2aXNpdG9yLCBjb250ZXh0KSwgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYSBUeXBlU2NyaXB0IG5vbi1udWxsIGFzc2VydGlvbiBpbnRvIGEgQ2xvc3VyZSBDYXN0LCBieSBzdHJpcHBpbmcgfG51bGwgYW5kXG4gICAgICAgKiB8dW5kZWZpbmVkIGZyb20gYSB1bmlvbiB0eXBlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiB2aXNpdE5vbk51bGxFeHByZXNzaW9uKG5vbk51bGw6IHRzLk5vbk51bGxFeHByZXNzaW9uKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihub25OdWxsLmV4cHJlc3Npb24pO1xuICAgICAgICBjb25zdCBub25OdWxsVHlwZSA9IHR5cGVDaGVja2VyLmdldE5vbk51bGxhYmxlVHlwZSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNsb3N1cmVDYXN0KFxuICAgICAgICAgICAgbm9uTnVsbCwgdHMudmlzaXRFYWNoQ2hpbGQobm9uTnVsbCwgdmlzaXRvciwgY29udGV4dCksIG5vbk51bGxUeXBlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmlzaXRJbXBvcnREZWNsYXJhdGlvbihpbXBvcnREZWNsOiB0cy5JbXBvcnREZWNsYXJhdGlvbikge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGZvcndhcmQgZGVjbGFyZSBzaWRlIGVmZmVjdCBpbXBvcnRzLlxuICAgICAgICBpZiAoIWltcG9ydERlY2wuaW1wb3J0Q2xhdXNlKSByZXR1cm4gaW1wb3J0RGVjbDtcbiAgICAgICAgLy8gSW50cm9kdWNlIGEgZ29vZy5mb3J3YXJkRGVjbGFyZSBmb3IgdGhlIG1vZHVsZSwgc28gdGhhdCBpZiBUeXBlU2NyaXB0IGRvZXMgbm90IGVtaXQgdGhlXG4gICAgICAgIC8vIG1vZHVsZSBiZWNhdXNlIGl0J3Mgb25seSB1c2VkIGluIHR5cGUgcG9zaXRpb25zLCB0aGUgSlNEb2MgY29tbWVudHMgc3RpbGwgcmVmZXJlbmNlIGFcbiAgICAgICAgLy8gdmFsaWQgQ2xvc3VyZSBsZXZlbCBzeW1ib2wuXG4gICAgICAgIGNvbnN0IHN5bSA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oaW1wb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIpO1xuICAgICAgICAvLyBTY3JpcHRzIGRvIG5vdCBoYXZlIGEgc3ltYm9sLCBhbmQgbmVpdGhlciBkbyB1bnVzZWQgbW9kdWxlcy4gU2NyaXB0cyBjYW4gc3RpbGwgYmVcbiAgICAgICAgLy8gaW1wb3J0ZWQsIGVpdGhlciBhcyBzaWRlIGVmZmVjdCBpbXBvcnRzIG9yIHdpdGggYW4gZW1wdHkgaW1wb3J0IHNldCAoXCJ7fVwiKS4gVHlwZVNjcmlwdFxuICAgICAgICAvLyBkb2VzIG5vdCBlbWl0IGEgcnVudGltZSBsb2FkIGZvciBhbiBpbXBvcnQgd2l0aCBhbiBlbXB0eSBsaXN0IG9mIHN5bWJvbHMsIGJ1dCB0aGUgaW1wb3J0XG4gICAgICAgIC8vIGZvcmNlcyBhbnkgZ2xvYmFsIGRlY2xhcmF0aW9ucyBmcm9tIHRoZSBsaWJyYXJ5IHRvIGJlIHZpc2libGUsIHdoaWNoIGlzIHdoYXQgdXNlcnMgdXNlXG4gICAgICAgIC8vIHRoaXMgZm9yLiBObyBzeW1ib2xzIGZyb20gdGhlIHNjcmlwdCBuZWVkIGZvcndhcmQgZGVjbGFyYXRpb24sIHNvIGp1c3QgcmV0dXJuLlxuICAgICAgICBpZiAoIXN5bSkgcmV0dXJuIGltcG9ydERlY2w7XG4gICAgICAgIC8vIFdyaXRlIHRoZSBleHBvcnQgZGVjbGFyYXRpb24gaGVyZSBzbyB0aGF0IGZvcndhcmQgZGVjbGFyZXMgY29tZSBhZnRlciBpdCwgYW5kXG4gICAgICAgIC8vIGZpbGVvdmVydmlldyBjb21tZW50cyBkbyBub3QgZ2V0IG1vdmVkIGJlaGluZCBzdGF0ZW1lbnRzLlxuICAgICAgICBjb25zdCBpbXBvcnRQYXRoID0gZ29vZ21vZHVsZS5yZXNvbHZlTW9kdWxlTmFtZShcbiAgICAgICAgICAgIHtvcHRpb25zOiB0c09wdGlvbnMsIGhvc3Q6IHRzSG9zdH0sIHNvdXJjZUZpbGUuZmlsZU5hbWUsXG4gICAgICAgICAgICAoaW1wb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dCk7XG5cbiAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3IuZm9yd2FyZERlY2xhcmUoXG4gICAgICAgICAgICBpbXBvcnRQYXRoLCBzeW0sIC8qIGlzRXhwbGljaXRseUltcG9ydGVkPyAqLyB0cnVlLFxuICAgICAgICAgICAgLyogZGVmYXVsdCBpbXBvcnQ/ICovICEhaW1wb3J0RGVjbC5pbXBvcnRDbGF1c2UubmFtZSk7XG4gICAgICAgIHJldHVybiBpbXBvcnREZWNsO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsb3N1cmUgQ29tcGlsZXIgd2lsbCBmYWlsIHdoZW4gaXQgZmluZHMgaW5jb3JyZWN0IEpTRG9jIHRhZ3Mgb24gbm9kZXMuIFRoaXMgZnVuY3Rpb25cbiAgICAgICAqIHBhcnNlcyBhbmQgdGhlbiByZS1zZXJpYWxpemVzIEpTRG9jIGNvbW1lbnRzLCBlc2NhcGluZyBvciByZW1vdmluZyBpbGxlZ2FsIHRhZ3MuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGVzY2FwZUlsbGVnYWxKU0RvYyhub2RlOiB0cy5Ob2RlKSB7XG4gICAgICAgIGNvbnN0IG1qc2RvYyA9IG1vZHVsZVR5cGVUcmFuc2xhdG9yLmdldE11dGFibGVKU0RvYyhub2RlKTtcbiAgICAgICAgbWpzZG9jLnVwZGF0ZUNvbW1lbnQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhIHZhbHVlIGV4cG9ydCBzaG91bGQgYmUgZW1pdHRlZCBmb3IgdGhlIGdpdmVuIHN5bWJvbCBpbiBleHBvcnQgKi4gKi9cbiAgICAgIGZ1bmN0aW9uIHNob3VsZEVtaXRWYWx1ZUV4cG9ydEZvclN5bWJvbChzeW06IHRzLlN5bWJvbCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpIHtcbiAgICAgICAgICBzeW0gPSB0eXBlQ2hlY2tlci5nZXRBbGlhc2VkU3ltYm9sKHN5bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5WYWx1ZSkgPT09IDApIHtcbiAgICAgICAgICAvLyBOb3RlOiBXZSBjcmVhdGUgZXhwbGljaXQgZXhwb3J0cyBvZiB0eXBlIHN5bWJvbHMgZm9yIGNsb3N1cmUgaW4gdmlzaXRFeHBvcnREZWNsYXJhdGlvbi5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0c09wdGlvbnMucHJlc2VydmVDb25zdEVudW1zICYmIHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkNvbnN0RW51bSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiB2aXNpdEV4cG9ydERlY2xhcmF0aW9uIGZvcndhcmQgZGVjbGFyZXMgZXhwb3J0ZWQgbW9kdWxlcyBhbmQgZW1pdHMgZXhwbGljaXQgZXhwb3J0cyBmb3JcbiAgICAgICAqIHR5cGVzICh3aGljaCBub3JtYWxseSBkbyBub3QgZ2V0IGVtaXR0ZWQgYnkgVHlwZVNjcmlwdCkuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHZpc2l0RXhwb3J0RGVjbGFyYXRpb24oZXhwb3J0RGVjbDogdHMuRXhwb3J0RGVjbGFyYXRpb24pOiB0cy5Ob2RlfHRzLk5vZGVbXSB7XG4gICAgICAgIGNvbnN0IGltcG9ydGVkTW9kdWxlU3ltYm9sID0gZXhwb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIgJiZcbiAgICAgICAgICAgIHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oZXhwb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIpITtcbiAgICAgICAgaWYgKGltcG9ydGVkTW9kdWxlU3ltYm9sKSB7XG4gICAgICAgICAgLy8gRm9yd2FyZCBkZWNsYXJlIGFsbCBleHBsaWNpdGx5IGltcG9ydGVkIG1vZHVsZXMsIHNvIHRoYXQgc3ltYm9scyBjYW4gYmUgcmVmZXJlbmNlZCBhbmRcbiAgICAgICAgICAvLyB0eXBlIG9ubHkgbW9kdWxlcyBnZXQgZm9yY2UtbG9hZGVkLlxuICAgICAgICAgIG1vZHVsZVR5cGVUcmFuc2xhdG9yLmZvcndhcmREZWNsYXJlKFxuICAgICAgICAgICAgICAoZXhwb3J0RGVjbC5tb2R1bGVTcGVjaWZpZXIgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dCwgaW1wb3J0ZWRNb2R1bGVTeW1ib2wsXG4gICAgICAgICAgICAgIC8qIGlzRXhwbGljaXRseUltcG9ydGVkPyAqLyB0cnVlLCAvKiBkZWZhdWx0IGltcG9ydD8gKi8gZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZXNUb0V4cG9ydDogQXJyYXk8W3N0cmluZywgdHMuU3ltYm9sXT4gPSBbXTtcbiAgICAgICAgaWYgKCFleHBvcnREZWNsLmV4cG9ydENsYXVzZSkge1xuICAgICAgICAgIC8vIGV4cG9ydCAqIGZyb20gJy4uLidcbiAgICAgICAgICAvLyBSZXNvbHZlIHRoZSAqIGludG8gYWxsIHZhbHVlIHN5bWJvbHMgZXhwb3J0ZWQsIGFuZCB1cGRhdGUgdGhlIGV4cG9ydCBkZWNsYXJhdGlvbi5cblxuICAgICAgICAgIC8vIEV4cGxpY2l0bHkgc3BlbGxlZCBvdXQgZXhwb3J0cyAoaS5lLiB0aGUgZXhwb3J0cyBvZiB0aGUgY3VycmVudCBtb2R1bGUpIHRha2UgcHJlY2VkZW5jZVxuICAgICAgICAgIC8vIG92ZXIgaW1wbGljaXQgb25lcyBmcm9tIGV4cG9ydCAqLiBVc2UgdGhlIGN1cnJlbnQgbW9kdWxlJ3MgZXhwb3J0cyB0byBmaWx0ZXIuXG4gICAgICAgICAgY29uc3QgY3VycmVudE1vZHVsZVN5bWJvbCA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24oc291cmNlRmlsZSk7XG4gICAgICAgICAgY29uc3QgY3VycmVudE1vZHVsZUV4cG9ydHMgPSBjdXJyZW50TW9kdWxlU3ltYm9sICYmIGN1cnJlbnRNb2R1bGVTeW1ib2wuZXhwb3J0cztcblxuICAgICAgICAgIGlmICghaW1wb3J0ZWRNb2R1bGVTeW1ib2wpIHtcbiAgICAgICAgICAgIG1vZHVsZVR5cGVUcmFuc2xhdG9yLmVycm9yKGV4cG9ydERlY2wsIGBleHBvcnQgKiB3aXRob3V0IG1vZHVsZSBzeW1ib2xgKTtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnREZWNsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBleHBvcnRlZFN5bWJvbHMgPSB0eXBlQ2hlY2tlci5nZXRFeHBvcnRzT2ZNb2R1bGUoaW1wb3J0ZWRNb2R1bGVTeW1ib2wpO1xuICAgICAgICAgIGNvbnN0IGV4cG9ydFNwZWNpZmllcnM6IHRzLkV4cG9ydFNwZWNpZmllcltdID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBzeW0gb2YgZXhwb3J0ZWRTeW1ib2xzKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudE1vZHVsZUV4cG9ydHMgJiYgY3VycmVudE1vZHVsZUV4cG9ydHMuaGFzKHN5bS5lc2NhcGVkTmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gV2UgbWlnaHQgaGF2ZSBhbHJlYWR5IGdlbmVyYXRlZCBhbiBleHBvcnQgZm9yIHRoZSBnaXZlbiBzeW1ib2wuXG4gICAgICAgICAgICBpZiAoZXhwYW5kZWRTdGFySW1wb3J0cy5oYXMoc3ltLm5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGV4cGFuZGVkU3RhckltcG9ydHMuYWRkKHN5bS5uYW1lKTtcbiAgICAgICAgICAgIC8vIE9ubHkgY3JlYXRlIGFuIGV4cG9ydCBzcGVjaWZpZXIgZm9yIHZhbHVlcyB0aGF0IGFyZSBleHBvcnRlZC4gRm9yIHR5cGVzLCB0aGUgY29kZVxuICAgICAgICAgICAgLy8gYmVsb3cgY3JlYXRlcyBzcGVjaWZpYyBleHBvcnQgc3RhdGVtZW50cyB0aGF0IG1hdGNoIENsb3N1cmUncyBleHBlY3RhdGlvbnMuXG4gICAgICAgICAgICBpZiAoc2hvdWxkRW1pdFZhbHVlRXhwb3J0Rm9yU3ltYm9sKHN5bSkpIHtcbiAgICAgICAgICAgICAgZXhwb3J0U3BlY2lmaWVycy5wdXNoKHRzLmNyZWF0ZUV4cG9ydFNwZWNpZmllcih1bmRlZmluZWQsIHN5bS5uYW1lKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0eXBlc1RvRXhwb3J0LnB1c2goW3N5bS5uYW1lLCBzeW1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwb3J0RGVjbCA9IHRzLnVwZGF0ZUV4cG9ydERlY2xhcmF0aW9uKFxuICAgICAgICAgICAgICBleHBvcnREZWNsLCBleHBvcnREZWNsLmRlY29yYXRvcnMsIGV4cG9ydERlY2wubW9kaWZpZXJzLFxuICAgICAgICAgICAgICB0cy5jcmVhdGVOYW1lZEV4cG9ydHMoZXhwb3J0U3BlY2lmaWVycyksIGV4cG9ydERlY2wubW9kdWxlU3BlY2lmaWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGV4cCBvZiBleHBvcnREZWNsLmV4cG9ydENsYXVzZS5lbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWROYW1lID0gdHJhbnNmb3JtZXJVdGlsLmdldElkZW50aWZpZXJUZXh0KGV4cC5uYW1lKTtcbiAgICAgICAgICAgIHR5cGVzVG9FeHBvcnQucHVzaChcbiAgICAgICAgICAgICAgICBbZXhwb3J0ZWROYW1lLCBtb2R1bGVUeXBlVHJhbnNsYXRvci5tdXN0R2V0U3ltYm9sQXRMb2NhdGlvbihleHAubmFtZSldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IGVtaXQgdHlwZWRlZiByZS1leHBvcnRzIGluIHVudHlwZWQgbW9kZS5cbiAgICAgICAgaWYgKGhvc3QudW50eXBlZCkgcmV0dXJuIGV4cG9ydERlY2w7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiB0cy5Ob2RlW10gPSBbZXhwb3J0RGVjbF07XG4gICAgICAgIGZvciAoY29uc3QgW2V4cG9ydGVkTmFtZSwgc3ltXSBvZiB0eXBlc1RvRXhwb3J0KSB7XG4gICAgICAgICAgbGV0IGFsaWFzZWRTeW1ib2wgPSBzeW07XG4gICAgICAgICAgaWYgKHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkFsaWFzKSB7XG4gICAgICAgICAgICBhbGlhc2VkU3ltYm9sID0gdHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChzeW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc1R5cGVBbGlhcyA9IChhbGlhc2VkU3ltYm9sLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVmFsdWUpID09PSAwICYmXG4gICAgICAgICAgICAgIChhbGlhc2VkU3ltYm9sLmZsYWdzICYgKHRzLlN5bWJvbEZsYWdzLlR5cGVBbGlhcyB8IHRzLlN5bWJvbEZsYWdzLkludGVyZmFjZSkpICE9PSAwO1xuICAgICAgICAgIGlmICghaXNUeXBlQWxpYXMpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IHR5cGVOYW1lID1cbiAgICAgICAgICAgICAgbW9kdWxlVHlwZVRyYW5zbGF0b3Iuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLmdldChhbGlhc2VkU3ltYm9sKSB8fCBhbGlhc2VkU3ltYm9sLm5hbWU7XG4gICAgICAgICAgY29uc3Qgc3RtdCA9IHRzLmNyZWF0ZVN0YXRlbWVudChcbiAgICAgICAgICAgICAgdHMuY3JlYXRlUHJvcGVydHlBY2Nlc3ModHMuY3JlYXRlSWRlbnRpZmllcignZXhwb3J0cycpLCBleHBvcnRlZE5hbWUpKTtcbiAgICAgICAgICBhZGRDb21tZW50T24oc3RtdCwgW3t0YWdOYW1lOiAndHlwZWRlZicsIHR5cGU6ICchJyArIHR5cGVOYW1lfV0pO1xuICAgICAgICAgIHRzLmFkZFN5bnRoZXRpY1RyYWlsaW5nQ29tbWVudChcbiAgICAgICAgICAgICAgc3RtdCwgdHMuU3ludGF4S2luZC5TaW5nbGVMaW5lQ29tbWVudFRyaXZpYSwgJyByZS1leHBvcnQgdHlwZWRlZicsIHRydWUpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHN0bXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgaWRlbnRpZmllcnMgZXhwb3J0ZWQgaW4gYSBzaW5nbGUgZXhwb3J0ZWQgc3RhdGVtZW50IC0gdHlwaWNhbGx5IGp1c3Qgb25lXG4gICAgICAgKiBpZGVudGlmaWVyIChlLmcuIGZvciBgZXhwb3J0IGZ1bmN0aW9uIGZvbygpYCksIGJ1dCBtdWx0aXBsZSBmb3IgYGV4cG9ydCBkZWNsYXJlIHZhciBhLCBiYC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZ2V0RXhwb3J0RGVjbGFyYXRpb25OYW1lcyhub2RlOiB0cy5Ob2RlKTogdHMuSWRlbnRpZmllcltdIHtcbiAgICAgICAgc3dpdGNoIChub2RlLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVmFyaWFibGVTdGF0ZW1lbnQ6XG4gICAgICAgICAgICBjb25zdCB2YXJEZWNsID0gbm9kZSBhcyB0cy5WYXJpYWJsZVN0YXRlbWVudDtcbiAgICAgICAgICAgIHJldHVybiB2YXJEZWNsLmRlY2xhcmF0aW9uTGlzdC5kZWNsYXJhdGlvbnMubWFwKChkKSA9PiBnZXRFeHBvcnREZWNsYXJhdGlvbk5hbWVzKGQpWzBdKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVmFyaWFibGVEZWNsYXJhdGlvbjpcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRnVuY3Rpb25EZWNsYXJhdGlvbjpcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSW50ZXJmYWNlRGVjbGFyYXRpb246XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb246XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1vZHVsZURlY2xhcmF0aW9uOlxuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5FbnVtRGVjbGFyYXRpb246XG4gICAgICAgICAgICBjb25zdCBkZWNsID0gbm9kZSBhcyB0cy5OYW1lZERlY2xhcmF0aW9uO1xuICAgICAgICAgICAgaWYgKCFkZWNsLm5hbWUgfHwgZGVjbC5uYW1lLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbZGVjbC5uYW1lXTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVHlwZUFsaWFzRGVjbGFyYXRpb246XG4gICAgICAgICAgICBjb25zdCB0eXBlQWxpYXMgPSBub2RlIGFzIHRzLlR5cGVBbGlhc0RlY2xhcmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIFt0eXBlQWxpYXMubmFtZV07XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1vZHVsZVR5cGVUcmFuc2xhdG9yLmVycm9yKFxuICAgICAgICAgICAgbm9kZSwgYHVuc3VwcG9ydGVkIGV4cG9ydCBkZWNsYXJhdGlvbiAke3RzLlN5bnRheEtpbmRbbm9kZS5raW5kXX06ICR7bm9kZS5nZXRUZXh0KCl9YCk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBbWJpZW50IGRlY2xhcmF0aW9ucyBkZWNsYXJlIHR5cGVzIGZvciBUeXBlU2NyaXB0J3MgYmVuZWZpdCwgYW5kIHdpbGwgYmUgcmVtb3ZlZGUgYnlcbiAgICAgICAqIFR5cGVTY3JpcHQgZHVyaW5nIGl0cyBlbWl0IHBoYXNlLiBEb3duc3RyZWFtIENsb3N1cmUgY29kZSBob3dldmVyIG1pZ2h0IGJlIGltcG9ydGluZ1xuICAgICAgICogc3ltYm9scyBmcm9tIHRoaXMgbW9kdWxlLCBzbyB0c2lja2xlIG11c3QgZW1pdCBhIENsb3N1cmUtY29tcGF0aWJsZSBleHBvcnRzIGRlY2xhcmF0aW9uLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiB2aXNpdEV4cG9ydGVkQW1iaWVudChub2RlOiB0cy5Ob2RlKTogdHMuTm9kZVtdIHtcbiAgICAgICAgaWYgKGhvc3QudW50eXBlZCB8fCAhc2hvdWxkRW1pdEV4cG9ydHNBc3NpZ25tZW50cygpKSByZXR1cm4gW25vZGVdO1xuXG4gICAgICAgIGNvbnN0IGRlY2xOYW1lcyA9IGdldEV4cG9ydERlY2xhcmF0aW9uTmFtZXMobm9kZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogdHMuTm9kZVtdID0gW25vZGVdO1xuICAgICAgICBmb3IgKGNvbnN0IGRlY2wgb2YgZGVjbE5hbWVzKSB7XG4gICAgICAgICAgY29uc3Qgc3ltID0gdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihkZWNsKSE7XG4gICAgICAgICAgY29uc3QgaXNWYWx1ZSA9IHN5bS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlO1xuICAgICAgICAgIC8vIE5vbi12YWx1ZSBvYmplY3RzIGRvIG5vdCBleGlzdCBhdCBydW50aW1lLCBzbyB3ZSBjYW5ub3QgYWNjZXNzIHRoZSBzeW1ib2wgKGl0IG9ubHlcbiAgICAgICAgICAvLyBleGlzdHMgaW4gZXh0ZXJucykuIEV4cG9ydCB0aGVtIGFzIGEgdHlwZWRlZiwgd2hpY2ggZm9yd2FyZHMgdG8gdGhlIHR5cGUgaW4gZXh0ZXJucy5cbiAgICAgICAgICAvLyBOb3RlOiBUeXBlU2NyaXB0IGVtaXRzIG9kZCBjb2RlIGZvciBleHBvcnRlZCBhbWJpZW50cyAoZXhwb3J0cy54IGZvciB2YXJpYWJsZXMsIGp1c3QgeFxuICAgICAgICAgIC8vIGZvciBldmVyeXRoaW5nIGVsc2UpLiBUaGF0IHNlZW1zIGJ1Z2d5LCBhbmQgaW4gZWl0aGVyIGNhc2UgdGhpcyBjb2RlIHNob3VsZCBub3QgYXR0ZW1wdFxuICAgICAgICAgIC8vIHRvIGZpeCBpdC5cbiAgICAgICAgICAvLyBTZWUgYWxzbyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzgwMTUuXG4gICAgICAgICAgaWYgKCFpc1ZhbHVlKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgZW1pdCByZS1leHBvcnRzIGZvciBNb2R1bGVEZWNsYXJhdGlvbnMuXG4gICAgICAgICAgICAvLyBBbWJpZW50IE1vZHVsZURlY2xhcmF0aW9ucyBhcmUgYWx3YXlzIHJlZmVyZW5jZWQgYXMgZ2xvYmFsIHN5bWJvbHMsIHNvIHRoZXkgZG9uJ3RcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgZXhwb3J0ZWQuXG4gICAgICAgICAgICBpZiAobm9kZS5raW5kID09PSB0cy5TeW50YXhLaW5kLk1vZHVsZURlY2xhcmF0aW9uKSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG1hbmdsZWROYW1lID0gbW9kdWxlTmFtZUFzSWRlbnRpZmllcihob3N0LCBzb3VyY2VGaWxlLmZpbGVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY2xOYW1lID0gdHJhbnNmb3JtZXJVdGlsLmdldElkZW50aWZpZXJUZXh0KGRlY2wpO1xuICAgICAgICAgICAgY29uc3Qgc3RtdCA9IHRzLmNyZWF0ZVN0YXRlbWVudChcbiAgICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFjY2Vzcyh0cy5jcmVhdGVJZGVudGlmaWVyKCdleHBvcnRzJyksIGRlY2xOYW1lKSk7XG4gICAgICAgICAgICBhZGRDb21tZW50T24oc3RtdCwgW3t0YWdOYW1lOiAndHlwZWRlZicsIHR5cGU6IGAhJHttYW5nbGVkTmFtZX0uJHtkZWNsTmFtZX1gfV0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RtdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZpc2l0b3Iobm9kZTogdHMuTm9kZSk6IHRzLk5vZGV8dHMuTm9kZVtdIHtcbiAgICAgICAgaWYgKGlzQW1iaWVudChub2RlKSkge1xuICAgICAgICAgIGlmICghdHJhbnNmb3JtZXJVdGlsLmhhc01vZGlmaWVyRmxhZyhub2RlIGFzIHRzLkRlY2xhcmF0aW9uLCB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRFeHBvcnRlZEFtYmllbnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChub2RlLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSW1wb3J0RGVjbGFyYXRpb246XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRJbXBvcnREZWNsYXJhdGlvbihub2RlIGFzIHRzLkltcG9ydERlY2xhcmF0aW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRXhwb3J0RGVjbGFyYXRpb246XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRFeHBvcnREZWNsYXJhdGlvbihub2RlIGFzIHRzLkV4cG9ydERlY2xhcmF0aW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbjpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdENsYXNzRGVjbGFyYXRpb24obm9kZSBhcyB0cy5DbGFzc0RlY2xhcmF0aW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSW50ZXJmYWNlRGVjbGFyYXRpb246XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlIGFzIHRzLkludGVyZmFjZURlY2xhcmF0aW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSGVyaXRhZ2VDbGF1c2U6XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRIZXJpdGFnZUNsYXVzZShub2RlIGFzIHRzLkhlcml0YWdlQ2xhdXNlKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3I6XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1ldGhvZERlY2xhcmF0aW9uOlxuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5HZXRBY2Nlc3NvcjpcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuU2V0QWNjZXNzb3I6XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRGdW5jdGlvbkxpa2VEZWNsYXJhdGlvbihub2RlIGFzIHRzLkZ1bmN0aW9uTGlrZURlY2xhcmF0aW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVGhpc0tleXdvcmQ6XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRUaGlzRXhwcmVzc2lvbihub2RlIGFzIHRzLlRoaXNFeHByZXNzaW9uKTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVmFyaWFibGVTdGF0ZW1lbnQ6XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRWYXJpYWJsZVN0YXRlbWVudChub2RlIGFzIHRzLlZhcmlhYmxlU3RhdGVtZW50KTtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlEZWNsYXJhdGlvbjpcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlBc3NpZ25tZW50OlxuICAgICAgICAgICAgZXNjYXBlSWxsZWdhbEpTRG9jKG5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlBhcmFtZXRlcjpcbiAgICAgICAgICAgIC8vIFBhcmFtZXRlciBwcm9wZXJ0aWVzIChlLmcuIGBjb25zdHJ1Y3RvcigvKiogZG9jcyAqLyBwcml2YXRlIGZvbzogc3RyaW5nKWApIG1pZ2h0IGhhdmVcbiAgICAgICAgICAgIC8vIEpTRG9jIGNvbW1lbnRzLCBpbmNsdWRpbmcgSlNEb2MgdGFncyByZWNvZ25pemVkIGJ5IENsb3N1cmUgQ29tcGlsZXIuIFByZXZlbnQgZW1pdHRpbmdcbiAgICAgICAgICAgIC8vIGFueSBjb21tZW50cyBvbiB0aGVtLCBzbyB0aGF0IENsb3N1cmUgZG9lc24ndCBlcnJvciBvbiB0aGVtLlxuICAgICAgICAgICAgLy8gU2VlIHRlc3RfZmlsZXMvcGFyYW1ldGVyX3Byb3BlcnRpZXMudHMuXG4gICAgICAgICAgICBjb25zdCBwYXJhbURlY2wgPSBub2RlIGFzIHRzLlBhcmFtZXRlckRlY2xhcmF0aW9uO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVyVXRpbC5oYXNNb2RpZmllckZsYWcoXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtRGVjbCwgdHMuTW9kaWZpZXJGbGFncy5QYXJhbWV0ZXJQcm9wZXJ0eU1vZGlmaWVyKSkge1xuICAgICAgICAgICAgICB0cy5zZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHMocGFyYW1EZWNsLCBbXSk7XG4gICAgICAgICAgICAgIGpzZG9jLnN1cHByZXNzTGVhZGluZ0NvbW1lbnRzUmVjdXJzaXZlbHkocGFyYW1EZWNsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5UeXBlQWxpYXNEZWNsYXJhdGlvbjpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdFR5cGVBbGlhc0RlY2xhcmF0aW9uKG5vZGUgYXMgdHMuVHlwZUFsaWFzRGVjbGFyYXRpb24pO1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Bc0V4cHJlc3Npb246XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlR5cGVBc3NlcnRpb25FeHByZXNzaW9uOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0QXNzZXJ0aW9uRXhwcmVzc2lvbihub2RlIGFzIHRzLlR5cGVBc3NlcnRpb24pO1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Ob25OdWxsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdE5vbk51bGxFeHByZXNzaW9uKG5vZGUgYXMgdHMuTm9uTnVsbEV4cHJlc3Npb24pO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHMudmlzaXRFYWNoQ2hpbGQobm9kZSwgdmlzaXRvciwgY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZUZpbGUgPSB0cy52aXNpdEVhY2hDaGlsZChzb3VyY2VGaWxlLCB2aXNpdG9yLCBjb250ZXh0KTtcblxuICAgICAgcmV0dXJuIG1vZHVsZVR5cGVUcmFuc2xhdG9yLmluc2VydEZvcndhcmREZWNsYXJlcyhzb3VyY2VGaWxlKTtcbiAgICB9O1xuICB9O1xufVxuIl19